---
layout: post
title: "从浏览器的多进程到JS的单线程，JS的运行机制。"
date: 2019-06-06 20:00
comments: true
categories:
 	- JS
tags: 
    - JS
    - 浏览器
---

> 从浏览器多进程，到JS单线程，JS引擎的运行机制。

## 大纲 

- 线程和进程
- 浏览器是多进程的
- 梳理浏览器内核中线程之间的关系
- 浏览器渲染流程
- 从Event Loop谈JS的运行机制
- 事件循环进阶：macrotask与microtask

<!-- more -->

## 线程和进程

很多前端开发，不是很清楚线程和进程的区别。这里通过自己的理解，经查阅资料后，总结如下：

### 官方术语：

- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

### 通俗理解（人话）：

```
- 进程：是一个工厂，每个工厂都有它的独立资源 -> 系统分配的内存（独立的一块内存）

- 工厂和工厂之间相互独立 -> 进程之间相互独立

- 线程：是工厂中的工人，多个工人协作完成任务

- 工厂内有一个或多个工人 -> 一个进程包含一个或多个线程

- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）
```

注：通常情况下，我们说的单线程和多线程，都指的是在同一进程内运行。

## 浏览器是多进程的

- 浏览器是多进程的。
- 系统给浏览器分配了资源（内存、CPU）。
- 浏览器内，每个单独的Tab页，都相当于创建了一个独立的浏览器进程。

### 浏览器任务管理器：
![Chrome Process img](/assets/image/chromeProcess.png)

如图所示：在Chorme浏览器中开了多个Tab页，每个Tab页面都占一个独立的进程（独立的进程id），以及一个Chrome主进程。

**注：** 浏览器有自己的资源优化机制，如果打开多个空Tab页，在**任务管理器**中可以看到，可能被**合并**成一个进程了。

### 主要包含哪些进程：

#### Browser进程：即浏览器的主进程，主要负责：

- 浏览器的界面显示，及用户交互（当前页面的前进后退）。
- 其他页面的管理: 创建、销毁其他页面等。
- 页面的Render渲染。
- 网络资源的管理，下载等。

#### 第三方插件进程：

- 每个插件对应一个进程（指的是当前处于**激活**状态的插件）

#### GPU进程：

- 最多只有一个，用于页面的3D绘制等。

**注：**很多网站页面都有大量Flash广告或动画等，对配置一般的电脑CPU压力不小。GPU加速就是浏览器利用显卡的计算能力，实现提速和释放CPU。

#### Renderer进程：（内部是多线程的）

- 页面渲染，脚本执行，事件处理等。

### 多进程的优势：

- 单个页面或第三方插件**Crash**，不会影响整个浏览器。
- 充分利用设备**多核**优势。

### 浏览器内核（Renderer进程）:

大多时候，对于前端开发来讲，最重要、最需要清楚的就是**浏览器的渲染，即Renderer进程：**

- 页面的渲染，JS的执行，以及事件的轮询。

- 浏览器渲染进程，即Renderer进程是**多线程的**。

#### 主要包含哪些线程：

1. GUI渲染线程
    - 负责浏览器的界面渲染。
    ```
    - 根据HTML生成DOM Tree。
    - 根据CSS生成CSSOM。
    - 根据DOM Tree和CSSOM生成Render Tree。
    - 根据Render Tree开始渲染和展示。
    - 遇见<script>标签，执行，并阻塞渲染。（与JS引擎线程互斥）
    ```
2. JS引擎线程
    - 负责JavaScript脚本的处理和解析。（例如Chrome V8引擎）。
    - 等待着任务队列中任务的到来，然后加以处理，一个Tab页只有一个JS线程。

3. 事件触发线程
    - 归属于浏览器而不是JS引擎，用来事件轮询。
    - 当**JS引擎**执行代码块，例如***用户点击***，***定时器***，***网络请求***等异步Function。
    会将此任务添加到事件触发线程（即事件队列）中。
    - 当对应的事件符合触发的条件，被触发时，事件线程会将其添加到事件队列的队尾，等待**JS引擎**的处理。
4. 定时触发器线程
    ```setTimeout```和```setInterval```
    - 定时器不是由JS引擎计时的。因为JS引擎是单线程的，如果处于阻塞状态会影响计时的准确性。
    - 为了保证计时的准确性，就单独起一个线程，来做计时，计时完毕后，排在事件队列中，等待JS引擎空闲后执行。
5. HTTP网络请求线程
    - 在**XMLHttpRequest**，连接后，起一个新线程，触发请求。
    - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JS引擎执行。

!['Browser process'](/assets/image/browser-process.png)

到这里，Browser进程（即控制进程）与内核通信的主要流程如上。

#### Browser进程与内核的通信具体实例

当我们打开**任务管理器**后，新打开一个浏览器后，**任务管理器**中相应的增加了两个进程：
    1. 主控进程
    2. tab页面的渲染进程

紧接着，若页面非空白tab页的前提下，整个主要的渲染过程如下：
    1. Browser进程收到请求，先要获取页面内容，然后将RendererHost接口传递给Render进程。
    2. Render进程相应的接口收到消息，**处理后，交给渲染线程**，开始渲染：
        - 渲染线程收到收到请求，加载并渲染网页，期间可能需要Browser进程和GPU进程帮助渲染。
        - 期间，还可能会有JS线程进程DOM操作（操作可能会导致回流、重绘）。
        - 最后，**渲染结果**将传递给Browser进程。
    3. Browser进程收到结果并将结果绘制出来。

通信过程的过程：
!['Browser communication'](/assets/image/browser-communication.png)

注：以上，应该就是浏览器的一套运作流程了。（再往下深挖，看源码解析吧= =！）
--- 待整理