---
layout: post
title: "为什么const在'for...in'循环中起作用，而普通'for'循环中不起作用。"
date: 2019-06-22 21:00
comments: true
categories:
 	- JS
tags:
    - JS
    - ES6
---

> 最近写代码，在调ESLint时，发现**const**在for...in循环中，和普通for循环中，有一些不同。

## 变量声明

- 在传统的**JavaScript**中（非ES6），我们使用的是**var**关键字来做变量声明。不过其定义的变量存在：**没有块级作用域**，**存在变量提升**，**可重复声明**，**全局变量会自动添加全局window对象下**，**提前装载**等不足。

- 因此在ES6中，提供了两个新的声明变量的关键字：**let**和**const**，三者之间，存在着一些不同。

- 这里先通过对比三者的一些区别，来开始这个主题。

<!-- more -->

### 使用场景

- let使用场景：变量，替代var
- const使用场景：常量、声明匿名函数和箭头函数时。

### const命令

- let可以先声明变量，稍后赋值。const声明后必须马上赋值，否则会报错。
- const 简单类型的常量，一旦声明不可更改。复杂类型（对象，数组等）等指向指针的地址不能更改，内部数据可以改。

## 普通for循环中，var的行为：
!['var loop'](/blog/assets/image/varLoop.jpg)

- 从上图可以看到，**var**声明的变量循环，变量**i**在循环体的外部，依然能访问的到。
- 在大多数时候，我们希望把**i**变量限制在**{}**的局部作用域中。而不是全局的window中。

## 普通for循环中，let的行为：
!['let loop'](/blog/assets/image/letLoop.jpg)

- 从上图可以看到，**let**声明的变量循环，变量**j**在循环体的外部，访问会报错，变量**j**被限制在块级作用域内。
- 这样意味着，只能在其声明的**块{}**内部访问到。

## 普通for循环中，const的行为：

- 在上面已经说明了const的特殊之处，它定义的变量是不能重新分配或重新声明的常量。
- 由于这个原因，它是所有3个声明语句中**最安全**的选择。
- 下图为const声明变量的for循环。

!['const loop'](/blog/assets/image/constLoop.jpg)

- 它只执行了一次循环，随即出现了报错。
- 在传统的for循环中，迭代器只在操作开始时声明一次，所以这里是使用let的好地方!

## ESLint报错 **for...of** or **for...in** 循环中推荐使用const声明变量

### for...in
!['const in loop'](/blog/assets/image/constInLoop.jpg)

- 如上图，使用**for...in**的方式循环使用**const**声明变量是可以的！
- 在深入检查这些**for...in**循环类型之后，似乎它们在每次循环中都创建了一个新的块范围。这将意味着每个新索引实际上是一个新范围内的新变量，这样我们的**常量**永远不会被重新分配。

### for...in (let)
!['let in loop'](/blog/assets/image/letInLoop.jpg)

- 如上图，虽然迭代器每次在循环结束时乘以2，但是在下一次执行时，打印的索引只是我们循环遍历的数组中的下一个连续索引。但是在索引轮询结束后，函数块返回6(最后一个索引3乘以2)。
