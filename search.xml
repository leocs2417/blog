<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单点登录(SSO)</title>
      <link href="/blog/2022/03/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95(SSO)/"/>
      <url>/blog/2022/03/10/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95(SSO)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>是现阶段较流行的企业业务整合的解决方案之一。 SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p></blockquote><h2 id="技术背景："><a href="#技术背景：" class="headerlink" title="技术背景："></a>技术背景：</h2><ul><li>随着各大企业的业务范围的增大，大多会有多个同时使用的系统，每个系统都会有一套独立的登录模块。这样就会造成：使用人员在操作不同系统的时候，就需要多次进行登录的操作，不是很便捷。为了解决这个痛点，所以SSO就应运而生。</li></ul><a id="more"></a><h2 id="技术实现："><a href="#技术实现：" class="headerlink" title="技术实现："></a>技术实现：</h2><h3 id="1-普通登录的认证机制"><a href="#1-普通登录的认证机制" class="headerlink" title="1. 普通登录的认证机制"></a>1. 普通登录的认证机制</h3><p>  客户端(cookie) =&gt; 服务端(session)<br>  客户端登录后，会将cookie传给服务端，服务端通过cookie找到对应的唯一登录态session，来判断当前用户是否登录</p><h3 id="2-同一个顶级域名的“单点登录”"><a href="#2-同一个顶级域名的“单点登录”" class="headerlink" title="2. 同一个顶级域名的“单点登录”"></a>2. 同一个顶级域名的“单点登录”</h3><p>  如果同一个域名下，存在着多个系统，分别对应着不同的子域名，此时还是可以<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#cookie_%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F" target="_blank" rel="noopener">将cookie存到顶级域名</a>上去，从而实现多个子域名可以同时访问同一个cookie，进而服务端通过共享session来实现这个同域下的“单点登录”。</p><h3 id="3-真正的单点登录实现逻辑"><a href="#3-真正的单点登录实现逻辑" class="headerlink" title="3. 真正的单点登录实现逻辑"></a>3. 真正的单点登录实现逻辑</h3><p>  通常我们所指的单点登录，是在不同域下的。<br>  <img src="/blog/assets/image/sso.png" alt="&#39;sso&#39;"></p><p>  上图为CAS官网上的标准流程图，具体流程如下：</p><ol><li>用户访问app系统，app系统是需要登录的，但用户现在没有登录。</li><li>跳转到CAS server，即SSO登录系统。 SSO系统也没有登录，弹出用户登录页。</li><li>用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。</li><li>SSO系统登录完成后，服务端会生成一个Service Ticket，然后跳转到app系统，同时将Ticket参数传回给app系统。</li><li>app系统拿到Ticket后，后台向SSO发送请求，验证有效性。</li><li>验证通过后，app系统将登录态写入session，并设置app域下的Cookie。</li></ol><p>至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。</p><ol><li>用户访问app2系统，app2系统没有登录，跳转到SSO系统。</li><li>由于此时SSO已经登录了，则不需要重新登录。</li><li>SSO生成Ticket，浏览器跳转到app2系统，并将Ticket作为参数传递给app2。</li><li>此时同样，app2拿到Ticket后，后台向SSO发送请求，验证有效性。</li><li>验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。</li></ol><p>这个过程就是SSO系统的思路和逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高性能渲染长列表?</title>
      <link href="/blog/2020/09/21/%E5%A6%82%E4%BD%95%E9%AB%98%E6%80%A7%E8%83%BD%E6%B8%B2%E6%9F%93%E9%95%BF%E5%88%97%E8%A1%A8/"/>
      <url>/blog/2020/09/21/%E5%A6%82%E4%BD%95%E9%AB%98%E6%80%A7%E8%83%BD%E6%B8%B2%E6%9F%93%E9%95%BF%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在工作中, 可能会有遇到一些不能使用懒加载/分页查询的方式来进行列表的加载. 比如我们的<em>功能机</em>中的某个通话记录的列表, 类似这种, 需要实时查看列表而不是分页或者延时懒加载的, 我们称之为长列表.</p></blockquote><a id="more"></a><h2 id="问题-怎样高性能渲染此类型的长列表"><a href="#问题-怎样高性能渲染此类型的长列表" class="headerlink" title="问题:  怎样高性能渲染此类型的长列表?"></a>问题:  怎样高性能渲染此类型的长列表?</h2><p>由于数据量较大, 一次性渲染全部数据的话, 在性能较差的终端设备上, 就会比较卡顿.</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><ul><li><p>构建一个固定长度的虚拟列表 </p></li><li><p>监听滚动事件</p></li><li><p>动态替换列表中的元素</p></li></ul><p>如何不引入第三方库的前提下, 实现虚拟列表渲染的组件:</p><ul><li>这里以React项目为例:</li></ul><ol><li><strong>元素固定高度 - 简易代码</strong> : </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Maximum displayable number of visible area</span></span><br><span class="line"><span class="comment">// x = Math.ceil(screenHeight / itemHeight)</span></span><br><span class="line"><span class="keyword">const</span> MAX_ITEMS_SHOW = x;</span><br><span class="line"><span class="comment">// Fixed length of virtual rendering list (number of actual renderings)</span></span><br><span class="line"><span class="keyword">const</span> MAX_ITEMS_RENDER = y;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      index: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scroll(dir = <span class="string">'up'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; items &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">let</span> &#123; index &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir === <span class="string">'up'</span> &amp;&amp; index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      index -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir === <span class="string">'down'</span> &amp;&amp; index &lt; items.length - MAX_ITEMS_SHOW) &#123;</span><br><span class="line">      index += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; index &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  itemsToRender = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; items &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; index &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> items.slice(index, index + MAX_ITEMS_RENDER);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; className &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;className&#125;&gt;</span><br><span class="line">        &#123;itemsToRender&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default VirtualList;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>元素动态高度 - 代码</strong> :</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; from <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualList</span> <span class="title">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      visibleList: []</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.wholeList = [];</span><br><span class="line">    <span class="comment">// x: scroll step(rem)</span></span><br><span class="line">    <span class="keyword">this</span>.SCROLL_STEP = x;</span><br><span class="line">    <span class="keyword">this</span>.currentScrollPosition = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.visibleListCount = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">this</span>.startOffset = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    window.onkeydown = <span class="keyword">this</span>.onKeyDown.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; isFetched, wholeList, positions &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="comment">// First time update, set the whole to this.wholeList.</span></span><br><span class="line">    <span class="comment">// If use hooks-&gt; useEffect(), no need `isFetched`.</span></span><br><span class="line">    <span class="keyword">if</span> (isFetched &amp;&amp; !prevProps.isFetched) &#123;</span><br><span class="line">      <span class="keyword">this</span>.wholeList = wholeList;</span><br><span class="line">      <span class="keyword">this</span>.positions = positions;</span><br><span class="line">      <span class="keyword">this</span>.setVisibleList();</span><br><span class="line">      <span class="comment">// Use `querySelector` to get scollList instead of `this.ref` in render,</span></span><br><span class="line">      <span class="comment">// fetch whole list maybe async, if in render, refer will be triggered repeatedly.</span></span><br><span class="line">      <span class="keyword">this</span>.scrollList = document.querySelector(<span class="string">'.virtual-list-wrapper'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Current stage: only support up/down sroll.</span></span><br><span class="line">  <span class="comment">// Key down evt.</span></span><br><span class="line">  onKeyDown(evt) &#123;</span><br><span class="line">    evt.preventDefault();</span><br><span class="line">    evt.stopPropagation();</span><br><span class="line">    <span class="keyword">this</span>.scroll(evt.key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getStartIndex(list, value) &#123;</span><br><span class="line">    <span class="comment">// In order to reduce the search times about start index of visible list,</span></span><br><span class="line">    <span class="comment">// need a binary search here.</span></span><br><span class="line">    let start = <span class="number">0</span>;</span><br><span class="line">    let end = list.length - <span class="number">1</span>;</span><br><span class="line">    let tempIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">      <span class="keyword">const</span> midIndex = parseInt((start + end) / <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">const</span> midValue = list[midIndex];</span><br><span class="line">      <span class="keyword">if</span> (midValue === value) &#123;</span><br><span class="line">        <span class="keyword">return</span> midIndex + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (midValue &lt; value) &#123;</span><br><span class="line">        start = midIndex + <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midValue &gt; value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempIndex === <span class="number">0</span> || tempIndex &gt; midIndex) &#123;</span><br><span class="line">          tempIndex = midIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        end -= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempIndex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setVisibleList(startIndex = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> endIndex = Math.min(</span><br><span class="line">      startIndex + <span class="keyword">this</span>.visibleListCount,</span><br><span class="line">      <span class="keyword">this</span>.wholeList.length</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      visibleList: <span class="keyword">this</span>.wholeList.slice(startIndex, endIndex)</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scrollVisibleList() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; listHeight &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="comment">// If the client window can display the whole data completely,</span></span><br><span class="line">    <span class="comment">// there is no need to scroll.</span></span><br><span class="line">    <span class="keyword">const</span> isNeedScroll = listHeight &gt; <span class="keyword">this</span>.scrollList.clientHeight;</span><br><span class="line">    <span class="keyword">if</span> (!isNeedScroll) &#123;</span><br><span class="line">      <span class="keyword">this</span>.startOffset = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> startIndex = <span class="keyword">this</span>.getStartIndex(</span><br><span class="line">      <span class="keyword">this</span>.positions,</span><br><span class="line">      currentScrollPosition</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// current startOffset item's height</span></span><br><span class="line">    <span class="keyword">const</span> currentStartItemSize =</span><br><span class="line">      <span class="number">0</span> === startIndex</span><br><span class="line">        ? <span class="keyword">this</span>.positions[startIndex]</span><br><span class="line">        : <span class="keyword">this</span>.positions[startIndex] - <span class="keyword">this</span>.positions[startIndex - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">this</span>.startOffset =</span><br><span class="line">      currentScrollPosition -</span><br><span class="line">      (currentScrollPosition % currentStartItemSize);</span><br><span class="line">    <span class="keyword">this</span>.setVisibleList(startIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scroll(dir = <span class="string">'up'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; scrollHeight, clientHeight &#125; = <span class="keyword">this</span>.scrollList;</span><br><span class="line">    <span class="keyword">if</span> (dir === <span class="string">'up'</span> &amp;&amp; <span class="keyword">this</span>.currentScrollPosition &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentScrollPosition -= <span class="keyword">this</span>.SCROLL_STEP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When scroll to the bottom, no need to set offset any more.</span></span><br><span class="line">    <span class="keyword">if</span> (dir === <span class="string">'down'</span> &amp;&amp; scrollHeight &gt; <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.currentScrollPosition + clientHeight &lt;= scrollHeight) &#123;</span><br><span class="line">      <span class="keyword">this</span>.currentScrollPosition += <span class="keyword">this</span>.SCROLL_STEP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.scrollList.scrollTop = <span class="keyword">this</span>.currentScrollPosition;</span><br><span class="line">    <span class="keyword">this</span>.scrollVisibleList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; listHeight &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">const</span> &#123; visibleList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'virtual-list-wrapper'</span>&gt;</span><br><span class="line">        &lt;div className=<span class="string">'phantom-list'</span> style=&#123;&#123; height: `$&#123;listHeight&#125;rem` &#125;&#125; /&gt;</span><br><span class="line">        &lt;div</span><br><span class="line">          className=<span class="string">'render-list'</span></span><br><span class="line">          style=&#123;&#123; transform: `translate3d(<span class="number">0</span>, $&#123;<span class="keyword">this</span>.startOffset&#125;rem, <span class="number">0</span>)` &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          &#123;visibleList&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> VirtualList;</span><br></pre></td></tr></table></figure><p>React官方推荐了使用<a href="https://github.com/bvaughn/react-window" target="_blank" rel="noopener">React-window</a>, 来做虚拟列表渲染</p><p><strong>注</strong>: 但是对于一些对代码体积大小非常敏感的移动端项目来说, 引入该库会增加大概十几kb, 这种应用场景下, 我们可以自己手动写一个符合需求的组件.</p><p>参考链接: <a href="https://juejin.cn/post/6844903982742110216" target="_blank" rel="noopener">https://juejin.cn/post/6844903982742110216</a></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React Virtual DOM</title>
      <link href="/blog/2020/07/14/React%20Virtual%20DOM/"/>
      <url>/blog/2020/07/14/React%20Virtual%20DOM/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如大家熟知，在目前主流的JS框架中，React, Vue均使用了虚拟DOM概念，来进行<strong>数据驱动视图的更新</strong>。</p></blockquote><p>下面我们分三个部分讨论一下虚拟DOM在React中的原理和特点。</p><ul><li><p>什么是虚拟DOM?</p></li><li><p>深入了解虚拟DOM</p></li><li><p>虚拟DOM中的diff概念</p></li></ul><a id="more"></a><h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM?"></a>什么是虚拟DOM?</h2><ol><li><p>DOM本质：<strong>浏览器</strong>的概念，用js对象来表示页面上的元素，并提供了<strong>操作dom对象的API</strong>。</p></li><li><p>虚拟DOM：用<strong>js对象</strong>的形式，来模拟页面上Dom嵌套关系。(格式见部分二)</p></li></ol><h2 id="深入了解虚拟DOM"><a href="#深入了解虚拟DOM" class="headerlink" title="深入了解虚拟DOM:"></a>深入了解虚拟DOM:</h2><h3 id="1-一段代码："><a href="#1-一段代码：" class="headerlink" title="1. 一段代码："></a>1. 一段代码：</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line"><span class="built_in">  return</span> (</span><br><span class="line">    &lt;<span class="keyword">div</span>&gt;hello world&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>过程：当组件的<code>state</code>或者<code>props</code>发生改变的时候，render函数就会重新执行。重新渲染页面。</li></ul><h3 id="2-一些相关的思考："><a href="#2-一些相关的思考：" class="headerlink" title="2. 一些相关的思考："></a>2. 一些相关的思考：</h3><ul><li><p>a. 如果没有React，我们该如何实现<strong>数据变化，更新视图</strong>的功能？</p></li><li><p>思路1： </p><ol><li><p>定义<code>state</code>, 先有数据</p></li><li><p><code>jsx</code>模板</p></li><li><p><code>state</code> + <code>template</code>  结合 -&gt; 生成真实的DOM，渲染</p></li><li><p><code>state</code>发生改变</p></li><li><p><code>state</code> + <code>template</code> 结合 -&gt; 生成新的DOM，替换原始的DOM</p></li></ol></li><li><p>思路1的缺陷：</p><p>第一次生成了一个完整的DOM片段</p><p>第二次生成了一个完整的DOM片段</p><p>第二次生成的DOM替换第一次的DOM，<strong>非常耗性能</strong></p></li><li><p>思路1的改良尝试：思路2:</p><ol><li><p>定义state, 先有数据</p></li><li><p><code>jsx</code>模板</p></li><li><p><code>state</code> + <code>template</code> 结合 -&gt; 生成真实的DOM， 渲染</p></li><li><p><code>state</code>发生改变</p></li><li><p><code>state</code> + <code>template</code> 结合 -&gt; 生成新的DOM，<strong>并不直接</strong>替换原始的DOM</p></li><li><p>新的DOM(<code>Document Fragment</code>：文档碎片)和原始的DOM做比对，找差异</p></li><li><p>eg: 找出<code>input</code>框发生了变化</p></li><li><p>只用新的DOM中的改变的<code>input</code>元素，替换掉老的DOM中的<code>input</code>元素 <strong>此步骤性能得以提升</strong></p></li></ol></li><li><p>2的缺陷：DOM比对，多消耗性能，故性能的提升并不明显。</p></li><li><p>思路3：</p><ol><li><p><code>state</code>数据</p></li><li><p><code>jsx</code>模板</p></li><li><p><code>state</code> + <code>template</code> 结合，生成真实DOM，来显示</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"abc"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="4"><li><p>生成虚拟DOM(虚拟DOM就是一个JS对象，用来<strong>描述</strong>真实DOM)</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">'div</span>', &#123;id: <span class="symbol">'abc</span>'&#125;, [<span class="symbol">'span</span>', &#123;&#125;, <span class="symbol">'Hello</span>, world']]</span><br></pre></td></tr></table></figure></li><li><p>当 state发生变化 eg: Hello, world -&gt; Bye bye</p></li><li><p><code>state</code> + <code>template</code> 生成新的虚拟DOM (<strong>极大的提升了性能</strong>)</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">'div</span>', &#123;id: <span class="symbol">'abc</span>'&#125;, [<span class="symbol">'span</span>', &#123;&#125;, <span class="symbol">'Bye</span> bye']]</span><br></pre></td></tr></table></figure></li><li><p>比较原始的虚拟DOM和新的虚拟DOM的区别，eg: 找到区别：是<code>span</code>中的内容</p></li><li><p>直接操作DOM，改变<code>span</code>中的内容</p></li></ol><ul><li>3性能的减弱：生成虚拟DOM，多生成了一个JS对象，</li></ul><p>但是， 生成一个JS对象相对的代价非常小；JS生成<strong>DOM</strong>代价极高：JS创建一个JS对象很简单，而创建DOM需要调用Web Appliction级别的API，性能损耗较大</p><ul><li><p>c性能的提升点： </p><ol start="6"><li><p>生成新的虚拟DOM，创建了一个JS对象，极大的提升性能</p></li><li><p>比对虚拟DOM，极大的提升性能</p></li></ol></li></ul><p><strong>注：</strong> 实际上，真实的react中，先生成虚拟DOM，然后根据虚拟DOM的结构，生成真实的DOM，来显示</p><ul><li>一段代码：</li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      /<span class="regexp">/ JSX -&gt; `createElement` -&gt; 虚拟DOM(JS 对象) -&gt; 真实的DOM</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;&lt;span&gt;hello, world&lt;/span</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ return React.createElement('div', &#123;&#125;, React.createElement('span', &#123;&#125;, 'hello, world' ))</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><p>这样做的优点：</p><ol><li><p>性能提升了。</p></li><li><p>它使得跨端应用得以实现。RN(只有浏览器识别真实DOM，故可以通过虚拟DOM，被原生移动端识别)</p></li></ol><h2 id="虚拟DOM中的diff算法"><a href="#虚拟DOM中的diff算法" class="headerlink" title="虚拟DOM中的diff算法:"></a>虚拟DOM中的diff算法:</h2><ol><li><p>先看一下todolist demo:</p></li><li><p>几个问题：</p></li></ol><ul><li><p>问题1：什么时候会发生数据的变化？</p><p>props, state的改变-&gt; 归根结底都是调用setState的时候</p></li><li><p>问题2：哪一步需要diff? </p><p>比较原始虚拟DOM和新的虚拟DOM的比对，找出差异。</p></li><li><p>问题3：setSate 关键字：异步 (为什么？若连续setState三次，之更新一次虚拟DOM)</p><p><img src="/blog/assets/image/reactState.jpg" alt="&#39;state&#39;"></p></li><li><p>问题4：怎么比对的？逻辑是什么？</p><p>从顶层开始，逐层，同层比对：<br><img src="/blog/assets/image/reactDiff.jpg" alt="&#39;diff&#39;"></p><p>a. 做法：若某一层不同，下边所有节点全部更新。</p><p>b. 另一个问题：若是这样做，只有外层一层不一样，下边所有子节点全相同，岂不是很浪费？</p><p>c. 为什么这样：同层比对的算法，简单，比对速度快，进而减少了比对算法上的性能消耗</p></li></ul><ol start="3"><li><p>without keys VS with keys</p><p><img src="/blog/assets/image/reactKeys.jpg" alt="&#39;keys&#39;"></p><p>场景：</p><ul><li><p>假设有一个数组，包含五个数据，页面第一次渲染时，会把这五个数据映射成五个虚拟DOM节点，生成虚拟DOM树，如图左。</p></li><li><p>接着添加一个新的内容，数据发生变化，生成新的虚拟DOM树。</p></li><li><p>接着对前后2个虚拟DOM进行对比，如果每一个节点，都没有一个自己的key值，节点和节点之间的关系就很难被对应上，所以需要两层循环比较。</p></li></ul><p>改善：</p><ul><li>如图右侧，给每个节点增加一个key，这样在比对的时候，就可以轻松发现一一对应的关系，只有<code>z</code>不同，这个时候，快速建立起关联后，只把<code>z</code>加进去即可。</li></ul><p>注：why no index as key in loop?</p><ul><li><p>若key值为index，在新的虚拟DOM树上，没办法保证前后key值一致。</p><p>举例说明：再看一下<code>todolist</code> demo:</p><ul><li><p>a:0 b: 1 c: 2  -&gt; 删除a，重新渲染</p></li><li><p>b: 0 c: 1 -&gt; 前后index值不一样，故失去了快速比对的条件。</p></li></ul></li></ul></li></ol><p>写在最后：<br>Keys should be stable, predictable, and unique.Unstable keys (like those produced by Math.random() will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过手写一个简单的Redux, 了解实现原理</title>
      <link href="/blog/2020/05/07/%E9%80%9A%E8%BF%87%E6%89%8B%E5%86%99Redux,%20%E4%BA%86%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2020/05/07/%E9%80%9A%E8%BF%87%E6%89%8B%E5%86%99Redux,%20%E4%BA%86%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Redux本身其实只是单纯的状态管理库, 不跟任何界面UI相关.</p></blockquote><p>我们先从基本的用法入手, 然后尝试使用手动实现一个简易的Redux.</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h2><p>(来自Redux 中文网)<br>Redux是针对<code>JavaScript</code>应用程序的可预测状态容器.</p><p>它可以帮助您编写性能一致、在不同环境（客户端、服务器和原生环境）中运行且易于测试的应用程序.最重要的是, 它提供了出色的开发人员体验, 例如 带有时间旅行调试器的实时代码编辑.</p><p>可以将<code>Redux</code> 与<code>React</code>或任何其他类似的工具库一起使用. 他的体积很小（算上依赖也只有 2kB, 但是在其生态系统中有大量插件可用.</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用:"></a>如何使用:</h3><p>Redux在使用层面上, 主要分三个部分: <code>Store</code>, <code>Actions</code>, <code>Reducers</code>.</p><h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><ul><li>用途: 存储(State)状态的仓库, 和一些操作状态的API, 使用用例: 初始化一个累加器的状态.</li></ul><h4 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h4><ul><li>用途: 改变Store中的某个状态, 使用用例: 想在num上, 进行加操作.</li></ul><h4 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a>Reducers</h4><ul><li>用途: 上边的State中, 只是<strong>想</strong>添加一项item, 实际操作要使用Reducer: 根据接收的action参数, 来改变Store中的状态</li></ul><h4 id="整合简单实例"><a href="#整合简单实例" class="headerlink" title="整合简单实例:"></a>整合简单实例:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reducer 部分</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">num: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'ADD_NUM'</span>:</span><br><span class="line"><span class="keyword">return</span> &#123; ...state, <span class="attr">num</span>: state.num + action.count &#125;;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store 部分</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer &#125; <span class="keyword">from</span> <span class="string">'./reducer'</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某个使用`num`的组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe: 订阅状态改变</span></span><br><span class="line"><span class="comment">// 一旦store发生了变化, 传入的回调函数就会被调用</span></span><br><span class="line"><span class="comment">// 页面UI的更新操作, 就是在这里执行的</span></span><br><span class="line"><span class="comment">// getState: 返回当前的state</span></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.getState()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch: 分发状态改变的动作</span></span><br><span class="line"><span class="keyword">const</span> action = &#123; <span class="attr">type</span>: <span class="string">'ADD_NUM'</span>, <span class="attr">count</span>: <span class="number">2</span> &#125;;</span><br><span class="line">store.dispatch(action);</span><br></pre></td></tr></table></figure><p>以上代码片段: 就是<strong>使用</strong>Redux, 实现对变量<code>num</code>的加操作.</p><h3 id="实现一个简单的Redux"><a href="#实现一个简单的Redux" class="headerlink" title="实现一个简单的Redux"></a>实现一个简单的Redux</h3><h4 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h4><p>用途: 接收reducer方法作为参数, 然后返回一个Store对象.</p><p>核心: 发布订阅模式</p><ul><li>关于Store主要用到的几个函数: <code>subscribe</code>, <code>dispatch</code>, <code>getState</code>.</li></ul><p>代码: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createStore = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// state记录所有状态</span></span><br><span class="line">  <span class="keyword">let</span> state;              </span><br><span class="line"><span class="comment">// 保存所有注册的回调</span></span><br><span class="line">  <span class="keyword">let</span> listeners = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// subscribe: 保存传进来的回调函数</span></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">    listeners.push(callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dispatch: 就是将所有的回调拿出来依次执行就行</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> listener = listeners[i];</span><br><span class="line">      listener();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getState: 直接返回当前的state</span></span><br><span class="line">  <span class="keyword">const</span> getState = (state);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store: 集合相关函数并导出</span></span><br><span class="line">  <span class="keyword">const</span> store = &#123;</span><br><span class="line">    subscribe,</span><br><span class="line">    dispatch,</span><br><span class="line">    getState</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ... 一些错误处理</span></span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h4><p>用途: 顾名思义(Combined Reducers)组合Reducers, 当我们项目相对复杂后, 如果将所有逻辑都写在一个reducer里面, 会变得特别冗余, 这种情况下, 可以使用combineReducers这个API, 来模块化的编写多个reducer, 最后组合起来.</p><p>用法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultNum = &#123;</span><br><span class="line">num: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> numReducer = <span class="function">(<span class="params">state = defaultNum, action</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'ADD_NUM'</span>:</span><br><span class="line"><span class="keyword">return</span> &#123; ...state, <span class="attr">num</span>: state.num + action.count &#125;;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'DECREASE_NUM'</span>:</span><br><span class="line"><span class="keyword">return</span> &#123; ...state, <span class="attr">num</span>: state.num - action.count &#125;;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultTheme = &#123;</span><br><span class="line">  color: <span class="string">'red'</span>,</span><br><span class="line">fontSize: <span class="number">16</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">themeReducer</span>(<span class="params">state = defaultTheme, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'SET_THEME'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">color</span>: action.color &#125;;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'SET_FONTSIZE'</span>:</span><br><span class="line"><span class="keyword">return</span> &#123; ...state, <span class="attr">fontSize</span>: action.fontSize &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合reducer</span></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123; <span class="attr">numState</span>: numReducer, <span class="attr">themeState</span>: themeReducer &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.getState()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作num的action</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'ADD_NUM'</span>, <span class="attr">count</span>: <span class="number">1</span> &#125;);</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREASE_NUM'</span>, <span class="attr">count</span>: <span class="number">2</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作theme的action</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'SET_THEME'</span>, <span class="attr">color</span>: <span class="string">'green'</span> &#125;);</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'SET_FONTSIZE'</span>, <span class="attr">fontSize</span>: <span class="number">18</span> &#125;);</span><br></pre></td></tr></table></figure><p>代码: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> combineReducers = <span class="function">(<span class="params">reducerMap</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 先把参数里面所有的键值拿出来</span></span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducerMap);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回值是一个普通结构的reducer函数</span></span><br><span class="line">  <span class="keyword">const</span> reducers = <span class="function">(<span class="params">state = &#123;&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newState = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> reducerKeys) &#123;</span><br><span class="line">      <span class="comment">// reducerKeys[i]: 对应每个reducer</span></span><br><span class="line">      <span class="comment">// 组合成reducer新的State: newState[key]集合</span></span><br><span class="line">      <span class="keyword">const</span> currentReducer = reducerMap[key];</span><br><span class="line">      <span class="keyword">const</span> prevState = state[key];</span><br><span class="line">      newState[key] = currentReducer(prevState, action);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ... 一些错误处理</span></span><br><span class="line">  <span class="keyword">return</span> reducers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展-Redux-功能"><a href="#拓展-Redux-功能" class="headerlink" title="拓展 Redux 功能"></a>拓展 Redux 功能</h3><p>大多数的应用都会使用<code>middleware</code>或<code>enhancer</code>来拓展 Redux store 的功能.（注：middleware 很常见, enhancer 不太常见） middleware 拓展了 Redux dispatch 函数的功能；enhancer 拓展了 Redux store 的功能.</p><p>我们将会添加如下两个 middleware 和 一个 enhancer：</p><p>redux-thunk middleware, 允许了简单的 dispatch 异步用法.<br>一个记录 dispatch 的 action 和得到的新 state 的 middleware.<br>一个记录 reducer 处理每个 action 所用时间的 enhancer.</p><h4 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h4><p>用途: 中间件是Redudx生态中较重要的一个概念, <code>applyMiddleware</code>就是用来引入相关的中间件的.</p><p>用法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger是一个中间件, 注意返回值嵌了好几层函数</span></span><br><span class="line"><span class="comment">// 我们后面来看看为什么这么设计</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.group(action.type)</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'dispatching'</span>, action)</span><br><span class="line">  <span class="keyword">let</span> result = next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.groupEnd()</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> logger</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用createStore时, 将applyMiddleware作为第二个参数传进去</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> store = createStore(reducer, applyMiddleware(logger));</span><br></pre></td></tr></table></figure><p>可以看到上述代码为了支持中间件, createStore传入了第二个参数, 这个参数官方称为enhancer, 顾名思义他是一个增强器, 用来增强store的能力的.官方对于enhancer的定义如下：</p><p><code>type StoreEnhancer = (next: StoreCreator) =&gt; StoreCreator</code></p><p>上面的结构的意思是说enhancer作为一个函数, 传进来一个参数StoreCreator, 同时return的也是一个StoreCreator相同结构的函数.</p><h4 id="使createStore支持enhancer"><a href="#使createStore支持enhancer" class="headerlink" title="使createStore支持enhancer"></a>使createStore支持enhancer</h4><p>代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, enhancer</span>) =&gt;</span> &#123;   <span class="comment">// 接收第二个参数enhancer</span></span><br><span class="line">  <span class="comment">// 先处理enhancer</span></span><br><span class="line">  <span class="comment">// 如果enhancer存在并且是函数</span></span><br><span class="line">  <span class="comment">// 我们将createStore作为参数传给他</span></span><br><span class="line">  <span class="comment">// 应该返回一个新的createStore</span></span><br><span class="line">  <span class="comment">// 我再拿这个新的createStore执行, 应该得到一个store</span></span><br><span class="line">  <span class="comment">// 最后返回这个store</span></span><br><span class="line">  <span class="keyword">if</span>(enhancer &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> newCreateStore = enhancer(createStore);</span><br><span class="line">    <span class="keyword">const</span> newStore = newCreateStore(reducer);</span><br><span class="line">    <span class="keyword">return</span> newStore;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果没有enhancer或者enhancer不是函数, 直接执行之前的逻辑</span></span><br><span class="line">  <span class="comment">// .......</span></span><br><span class="line">  <span class="keyword">const</span> store = &#123;</span><br><span class="line">    subscribe,</span><br><span class="line">    dispatch,</span><br><span class="line">    getState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore;</span><br></pre></td></tr></table></figure><h4 id="applyMiddleware-1"><a href="#applyMiddleware-1" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h4><p>前面我们已经有了enhancer的基本结构, applyMiddleware是作为第二个参数传给createStore的, 也就是说他是一个enhancer, 准确的说是applyMiddleware的返回值是一个enhancer, 因为我们传给createStore的是他的执行结果applyMiddleware():</p><p>一个中间件的具体结构:</p><ul><li>一个中间件接收store作为参数, 会返回一个函数</li><li>返回的这个函数接收老的dispatch函数作为参数, 会返回一个新的函数</li><li>返回的新函数就是新的dispatch函数, 这个函数里面可以拿到外面两层传进来的store和老dispatch函数</li></ul><p>代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applyMiddleware = <span class="function">(<span class="params">middleware</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> enhancer = <span class="function">(<span class="params">createStore</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newCreateStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 将middleware拿过来执行下, 传入store</span></span><br><span class="line">      <span class="comment">// 得到第一层函数</span></span><br><span class="line">      <span class="keyword">const</span> func = middleware(store);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 解构出原始的dispatch</span></span><br><span class="line">      <span class="keyword">const</span> &#123; dispatch &#125; = store;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 将原始的dispatch函数传给func执行</span></span><br><span class="line">      <span class="comment">// 得到增强版的dispatch</span></span><br><span class="line">      <span class="keyword">const</span> newDispatch = func(dispatch);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 返回的时候用增强版的newDispatch替换原始的dispatch</span></span><br><span class="line">      <span class="keyword">return</span> &#123;...store, <span class="attr">dispatch</span>: newDispatch&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newCreateStore;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> applyMiddleware;</span><br></pre></td></tr></table></figure><h4 id="多个中间件"><a href="#多个中间件" class="headerlink" title="多个中间件"></a>多个中间件</h4><p>示例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">applyMiddleware(</span><br><span class="line">  rafScheduler,</span><br><span class="line">  timeoutScheduler,</span><br><span class="line">  thunk,</span><br><span class="line">  vanillaPromise,</span><br><span class="line">  readyStatePromise,</span><br><span class="line">  logger,</span><br><span class="line">  crashReporter</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>返回的newDispatch里, 将传入的middleware依次的串行执行就行.<br>多个函数的串行执行可以使用辅助函数compose, 这个函数定义如下, 最终需返回一个包裹了所有方法的方法.</p><p>compose函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...func</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>支持多个中间件的实现:</p><p>内部结构:</p><ol><li>enhancer: 接收传入的store</li><li>newCreateStore: dispatch =&gt; newDispatch, 多个中间件的这层函数可以compose起来, 形成一个大的dispatch =&gt; newDispatch</li><li>return {…store, dispatch: newDispatch}.</li></ol><p>代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数支持多个中间件</span></span><br><span class="line"><span class="keyword">const</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> enhancer = <span class="function">(<span class="params">createStore</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> newCreateStore = <span class="function">(<span class="params">reducer</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 多个middleware, 先解构出dispatch =&gt; newDispatch的结构</span></span><br><span class="line">      <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(store));</span><br><span class="line">      <span class="keyword">const</span> &#123; dispatch &#125; = store;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 用compose得到一个组合了所有newDispatch的函数</span></span><br><span class="line">      <span class="keyword">const</span> newDispatchGen = compose(...chain);</span><br><span class="line">      <span class="comment">// 得到newDispatch</span></span><br><span class="line">      <span class="keyword">const</span> newDispatch = newDispatchGen(dispatch);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;...store, <span class="attr">dispatch</span>: newDispatch&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newCreateStore;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> applyMiddleware;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>Redux本身只是一个状态存储仓库(store).</p></li><li><p>store: 里面存了所有的状态(state).</p></li><li><p>改变state: 通过dispatch(action).</p></li><li><p>分发出去的action: 通过reducer来处理, 处理后得到并返回新的state.</p></li><li><p>subscribe: 订阅状态改变, 一旦store发生了变化, 传入的回调函数就会被调用.</p></li><li><p>enhancer: 其实就是一个装饰者模式, 传入当前的createStore, 返回一个增强的createStore.</p></li><li><p>可以使用<code>applyMiddleware</code>添加中间件, applyMiddleware的返回值就是一个enhancer. 中间件也是一个装饰者模式, 传入当前的dispatch, return一个enhancer的dispatch.</p></li><li><p>Redux只涉及数据层: 不涉及UI层.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Object.create和{}的区别</title>
      <link href="/blog/2020/03/30/Object.create()%E5%92%8C%7B%7D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2020/03/30/Object.create()%E5%92%8C%7B%7D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在 Vue 源码中，创建新对象都使用了<code>Object.create(null)</code>，而没有使用<code>{}</code>。</p></blockquote><p>在很多社区也都因为这个话题讨论过，特此记录一下。</p><a id="more"></a><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create():"></a>Object.create():</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><ul><li><code>Object.create()</code>方法创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</li></ul><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><p><code>Object.create(proto[, propertiesObject])</code></p><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul><li>proto</li></ul><p>新创建对象的原型对象。</p><ul><li>propertiesObject</li></ul><p>可选。如果没有指定为<code>undefined</code>，则是要添加到新创建对象的不可枚举（默认）属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应 Object.defineProperties()的第二个参数。</p><h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul><li>一个新对象，带着指定的原型对象和属性。</li></ul><h3 id="例子-MDN-："><a href="#例子-MDN-：" class="headerlink" title="例子(MDN)："></a>例子(MDN)：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  isHuman: <span class="literal">false</span>,</span><br><span class="line">  printIntroduction: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="keyword">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line">me.name = <span class="string">"Matthew"</span>; <span class="comment">// "name" is a property set on "me", but not on "person"</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; <span class="comment">// inherited properties can be overwritten</span></span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line"><span class="comment">// expected output: "My name is Matthew. Am I human? true"</span></span><br></pre></td></tr></table></figure><h2 id="Object-create-和-的对比："><a href="#Object-create-和-的对比：" class="headerlink" title="Object.create()和{}的对比：:"></a>Object.create()和{}的对比：:</h2><h3 id="："><a href="#：" class="headerlink" title="{}："></a>{}：</h3><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">o</span>: <span class="number">24</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><h4 id="output"><a href="#output" class="headerlink" title="output:"></a>output:</h4><p><img src="/blog/assets/image/object.png" alt="&#39;output&#39;"></p><p>从上图可以看到，使用<code>{}</code>新创建的对象，继承了<code>Object</code>自身的属性，例如<code>hasOwnProperty</code>、<code>toString</code>等，在新对象上可以直接使用。</p><h3 id="Object-create-1"><a href="#Object-create-1" class="headerlink" title="Object.create():"></a>Object.create():</h3><h4 id="例子：-1"><a href="#例子：-1" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">o</span> <span class="string">=</span> <span class="string">Object.create(null,</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  a:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    value:</span> <span class="number">24</span>   </span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">console.log(o);</span></span><br></pre></td></tr></table></figure><h4 id="output-1"><a href="#output-1" class="headerlink" title="output:"></a>output:</h4><p><img src="/blog/assets/image/object-create.png" alt="&#39;output&#39;"></p><p>由上图可见：新创建的属性，只有个自身一个属性<code>a</code>，其原型链上没有其他任何属性。也就是没有继承<code>Object</code>任何属性。若此时我们访问<code>o.toString()</code>会报错<code>Uncaught TypeError</code>。</p><h4 id="将第一个属性null改成-："><a href="#将第一个属性null改成-：" class="headerlink" title="将第一个属性null改成{}："></a>将第一个属性null改成{}：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">o</span> <span class="string">=</span> <span class="string">Object.create(&#123;&#125;,</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  a:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    value:</span> <span class="number">24</span>   </span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">console.log(o);</span></span><br></pre></td></tr></table></figure><h4 id="output-2"><a href="#output-2" class="headerlink" title="output:"></a>output:</h4><p><img src="/blog/assets/image/object-null.png" alt="&#39;output&#39;"></p><p>此时不难发现，此时已经具有了和<code>{}</code>几乎一样的属性了，除了多了一层<code>_proto_</code>。</p><h4 id="将第一个属性null改成Object-prototype："><a href="#将第一个属性null改成Object-prototype：" class="headerlink" title="将第一个属性null改成Object.prototype："></a>将第一个属性null改成Object.prototype：</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">o</span> <span class="string">=</span> <span class="string">Object.create(Object.prototype,</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  a:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    value:</span> <span class="number">24</span>   </span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">console.log(o);</span></span><br></pre></td></tr></table></figure><h4 id="output-3"><a href="#output-3" class="headerlink" title="output:"></a>output:</h4><p><img src="/blog/assets/image/object-proto.png" alt="&#39;output&#39;"></p><p>此时，已经和直接使用<code>{}</code>一样了。</p><h2 id="为什么使用Object-create-null"><a href="#为什么使用Object-create-null" class="headerlink" title="为什么使用Object.create(null)?"></a>为什么使用Object.create(null)?</h2><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Object</span>.<span class="keyword">create</span>(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h4 id="output-4"><a href="#output-4" class="headerlink" title="output:"></a>output:</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">//No properties</span></span><br></pre></td></tr></table></figure><ul><li><p>由此可见：使用这样的方式初始化一个新对象，没有任何属性，这样是一个比较纯净的<code>map</code>。这样就可以自行扩展原型链的属性，同样包括原来既有的<code>hasOwnProperty</code>，<code>toString</code>这样的属性。</p></li><li><p>所以，使用<code>Object.create(null);</code>，就不必担心原型链上的属性被覆盖。</p></li></ul><p>平时大多的普通场景，两者的差距并不是很在意，统一风格就好。</p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中, nextTick的实现原理</title>
      <link href="/blog/2019/11/11/Vue%E4%B8%AD%E7%9A%84nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2019/11/11/Vue%E4%B8%AD%E7%9A%84nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>nextTick 是 Vue 提供的一个官方 API，在 Vue 内部实现中，也经常用到。</p></blockquote><h2 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h2><ul><li>Vue 官方文档的解释是：在下次<code>DOM</code>更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的<code>DOM</code>。</li></ul><a id="more"></a><ul><li><p>相对简单的理解是：它可以在等待<code>DOM</code>更新完毕之后，再去执行一个回调。</p></li><li><p>官方例子：</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = 'Hello'</span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>next<span class="constructor">Tick(<span class="params">function</span> ()</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>next<span class="constructor">Tick()</span></span><br><span class="line">  .<span class="keyword">then</span>(<span class="keyword">function</span> <span class="literal">()</span> &#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="什么时候需要用这个-API？"><a href="#什么时候需要用这个-API？" class="headerlink" title="什么时候需要用这个 API？"></a>什么时候需要用这个 API？</h2><ul><li><p>尽管<strong>MVVM</strong>框架不推荐进行<code>DOM</code>操作，但实际工作中，难免会有这种时候，尤其是和第三方框架配合的过程中，在我的工作中，是以<code>table</code>、<code>offSet</code>相关的时候，较多会用到访问<code>DOM</code>。</p></li><li><p>故特此记录，<code>nextTick</code>的实现原理。</p></li></ul><h2 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h2><h3 id="源码位置：src-core-util-next-tick-js"><a href="#源码位置：src-core-util-next-tick-js" class="headerlink" title="源码位置：src/core/util/next-tick.js"></a>源码位置：<a href="https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js" target="_blank" rel="noopener">src/core/util/next-tick.js</a></h3><p>目前共<strong>110 行</strong>，相对比较易读。</p><h3 id="源码主要分为两个部分："><a href="#源码主要分为两个部分：" class="headerlink" title="源码主要分为两个部分："></a>源码主要分为两个部分：</h3><ul><li><p>能力检测</p></li><li><p>根据能力检测，以不同方式执行回调队列</p></li></ul><h4 id="能力检测："><a href="#能力检测：" class="headerlink" title="能力检测："></a>能力检测：</h4><ul><li><p>EventLoop 分为宏任务(macro task)，和微任务(micro task)，不论是执行宏任务还是微任务，完成后都会进入下一个 tick，并在前后两次 tick 中间，进行 render UI。</p></li><li><p>由于宏任务的执行耗时更长，所以在浏览器支持的前提下，优先使用微任务，否则，使用宏任务。</p></li><li><p>由于各宏任务也存在性能不一的情况，所以根据浏览器的支持，判断选择使用哪种宏任务。</p></li></ul><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="comment">// In problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此段<strong>检测代码</strong>可见，这里会进行一系列浏览器的检测：</p><ul><li><p>优先检测：是否支持原生的<code>Promise</code>，若支持，就使用此微任务，并将 Flag: <code>isUsingMicroTask</code>设为<code>true</code>。</p></li><li><p>若不支持，检测是否支持<code>MutationObserver</code>，若支持，则使用此微任务，同上，并将 Flag: <code>isUsingMicroTask</code>设为<code>true</code>。</p></li><li><p>若也不支持，检测是否支持<code>setImmediate</code>，若支持，则使用此宏任务。</p></li><li><p>若以上，都不支持，就只能使用性能最差的<code>setTimeout</code>了。</p></li></ul><h4 id="根据能力检测，以不同方式执行回调队列："><a href="#根据能力检测，以不同方式执行回调队列：" class="headerlink" title="根据能力检测，以不同方式执行回调队列："></a>根据能力检测，以不同方式执行回调队列：</h4><p>执行回调的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">'shared/util'</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">'./error'</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">'./env'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此段<strong>代码</strong>可见，这里的基本流程就是：</p><ul><li><p>接收回调函数，并将回调放进回调函数队列中。</p></li><li><p>在接收第一个回调时，执行上边<strong>能力检测</strong>中对应的异步方法。</p></li><li><p>如何保证只在接收第一个回调函数时执行异步方法？</p></li></ul><p>传入的<code>cb</code>会被<code>push</code>进<code>callbacks</code>中存放起来，然后执行<code>timerFunc</code>（<code>pending</code>是一个异步锁 Flag，保证<code>timerFunc</code>在下一个<code>tick</code>之前只执行一次）。</p><p>注：<code>timeFunc</code>即为上边性能检测对应的异步方法。</p><h4 id="实现一个简单的-nextTick："><a href="#实现一个简单的-nextTick：" class="headerlink" title="实现一个简单的 nextTick："></a>实现一个简单的 nextTick：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  callbacks.push(cb)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    setTimeout(flushCallback, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallback</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> copies = callbacks.slice()</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  copies.forEach(<span class="function"><span class="params">copy</span> =&gt;</span> &#123;</span><br><span class="line">    copy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由此代码可见：通过 nextTick 接收<code>cb</code>，使用<code>setTimeout</code>来异步执行<code>cb</code>。这样即可实现在 UI rerender 后，执行<code>cb</code>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优化Web移动端的加载速度?</title>
      <link href="/blog/2019/11/07/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96Web%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/"/>
      <url>/blog/2019/11/07/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96Web%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>电脑端有着更好的处理器, 并且与网络的连接, 通常比移动端设备的网络速度更快速和稳定. 通常情况下, 在网站中即使做了针对移动设备的优化, 加载速度可能也会比在电脑端慢.</p></blockquote><a id="more"></a><p>页面速度(或网站加载速度)是移动搜索引擎优化(SEO)的主要方面. Web性能不仅影响搜索排名, 影响用户的移动体验. </p><h2 id="如何优化移动端页面加载速度"><a href="#如何优化移动端页面加载速度" class="headerlink" title="如何优化移动端页面加载速度:"></a>如何优化移动端页面加载速度:</h2><h3 id="加载相关"><a href="#加载相关" class="headerlink" title="加载相关:"></a>加载相关:</h3><h4 id="首屏渲染优化"><a href="#首屏渲染优化" class="headerlink" title="首屏渲染优化:"></a>首屏渲染优化:</h4><ul><li><p>尽量避免<strong>非首屏资源</strong>的加载: </p><p>首屏渲染速度会直接影响终端用户对网站加载速度的印象, 首先要减少首屏渲染加载的资源, 进而加快首屏渲染速度.</p></li><li><p>采用<strong>组件化开发</strong>, 按需加载:</p><p>使用Vue/React等成熟第三方JS框架开发时, 可以配合webpack等使用组件/组件库的按需加载, 进而减少首屏加载的资源.</p></li></ul><h4 id="预加载和懒加载"><a href="#预加载和懒加载" class="headerlink" title="预加载和懒加载:"></a>预加载和懒加载:</h4><ul><li><p>预加载其他页面或资源:</p><p>在首屏渲染结束后, 可以先预先加载其他主要页面, 进而加快交互后的加载速度.</p></li><li><p>图片或列表的懒加载:</p><p>当用户主动点击/滚动交互到特定位置时, 采用<strong>LazyLoad</strong>的形式加载图片或列表等.</p></li></ul><ul><li><p>采用CDN加速</p><p>一些静态资源可以利用CDN的方式引入, 使其缓存在浏览器中, 进而减少开销.</p></li></ul><h3 id="资源压缩与合并"><a href="#资源压缩与合并" class="headerlink" title="资源压缩与合并:"></a>资源压缩与合并:</h3><h4 id="资源的压缩"><a href="#资源的压缩" class="headerlink" title="资源的压缩:"></a>资源的压缩:</h4><ul><li>图片的压缩: 利用第三方工具减小图片的体积.</li></ul><h4 id="资源合并"><a href="#资源合并" class="headerlink" title="资源合并"></a>资源合并</h4><ul><li><p>使用<code>CSS</code>雪碧图: 把需要的一些图片整合成一张</p><p>优点: 减少<strong>HTTP请求次数</strong>(backgroundPosition).</p><p>缺点: 图片比较大时, 加载慢, 且存在加载失败都不能显示的风险. </p></li><li><p>利用webpack等工具, 合理地<strong>合并代码</strong>, 进而减少<strong>HTTP请求次数</strong>.</p></li></ul><h3 id="合理利用缓存"><a href="#合理利用缓存" class="headerlink" title="合理利用缓存:"></a>合理利用缓存:</h3><ul><li><p>localStorage</p><p>一些非必要实时更新的参数, 可以利用缓存放在本地, 进而减少请求.</p></li></ul><h3 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化:"></a>渲染优化:</h3><ul><li><p>16ms优化:</p><p>目前大多数设备的屏幕刷新率仍为60hz, 每帧所消耗的时间约为16ms, 这16ms就是渲染帧的时长.</p><p>浏览器还有一些整理工作要做, 因此一次EventLoop内的视图渲染要在10ms内完成.</p><p>如果超出这个时间, 将会出现掉帧的表现.</p></li><li><p>减少重绘和重排(回流)</p><p>页面的重绘和重排(回流)很耗性能, 所以一定要尽可能减少页面的重绘和重排(回流), 例如页面图片大小变化、元素位置变化等这些情况都会导致重绘和重排(回流).</p></li></ul><h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流:"></a>防抖与节流:</h3><ul><li><p>常见场景: </p><p>窗口<strong>resize</strong>, <strong>scroll</strong>,以及input框中搜索请求数据等.</p></li><li><p>合理使用防抖/节流:</p><p>减少<strong>函数调用次数</strong>、<strong>网络请求次数</strong>.</p></li></ul><h3 id="为什么要减少HTTP请求"><a href="#为什么要减少HTTP请求" class="headerlink" title="为什么要减少HTTP请求?"></a>为什么要减少HTTP请求?</h3><ul><li><p>HTTP请求建立和释放需要时间:<br>客户端连接到Web服务器-&gt;发送HTTP请求-&gt;服务器接受请求并返回HTTP响应-&gt;释放连接TCP链接</p><p>如果http请求很多, 不合并http请求就会耗费大量时间再建立和释放上.</p></li><li><p>浏览器对同个域名下的并发请求数量是有限制的: </p><p>若并发请求过多, 后续的请求只能等前面的结束完后才开始.</p><p>所以要尽量减少页面的请求数, 首次加载同时请求数不能超过4个.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中函数的防抖(debounce)与节流(throttle)</title>
      <link href="/blog/2019/09/12/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2019/09/12/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在实际的用户交互过程中，无论是PC还是移动端，都会避免不了会用到<strong>防抖</strong>和<strong>节流</strong>来做相应的优化。</p></blockquote><p>常见使用场景：</p><ul><li>窗口resize,scroll,以及输入框中搜索请求数据等。</li></ul><a id="more"></a><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><ul><li><p>防抖：debounce。其概念就是<strong>去抖动</strong>，基本思路：将多次动作合并为一次动作执行。</p></li><li><p>节流：throttle。其概念就是<strong>减少动作的执行次数</strong>，基本思路：不能让用户的方法都不执行，而是在一定时间段内减少执行的次数，如果<strong>都不执行</strong>，就是debounce了。</p></li></ul><h2 id="防抖："><a href="#防抖：" class="headerlink" title="防抖："></a>防抖：</h2><ul><li><p>使用场景：<strong>input框</strong>的输入验证，用户连续点击提交等，防止用户的连续疯狂输入/点击按钮，导致短时间内多次访问服务器，压力过大、交互变卡。</p></li><li><p>实现思路：将目标动作放在一个setTimeout中，这个目标动作是一个事件的回调函数，如果这个回调在连续被调用，那么通过clearTimeout，这些次动作就都不被执行，直至最后一次触发回调函数，再执行。</p></li><li><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">fn, delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'clear timer if function re-call, until the last call'</span>);</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'call the fn'</span>)</span><br><span class="line">      fn();</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = debounce(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'some actions'</span>);</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="节流："><a href="#节流：" class="headerlink" title="节流："></a>节流：</h2><ul><li><p>使用场景：节流会用在比<strong>input框</strong>、<strong>click</strong>、<strong>keyup</strong>等事件，触发更频繁的场景下。例如：<strong>resize</strong>、<strong>scroll</strong>、<strong>touchmove</strong>、<strong>mousemove</strong>等事件下，由于此类事件触发更加频繁，所以使用节流来控制执行的频率。</p></li><li><p>实现思路：若想让用户的方法在特定时间段内只执行一次，我们需要保存上次执行的时间点与定时器。</p></li><li><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, threshHold = <span class="number">150</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>() - <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now - start &gt;= threshHold) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'now'</span>, now, now - start); <span class="comment">// about 150</span></span><br><span class="line">      fn();</span><br><span class="line">      start = now;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// call the fn() when out of the evts.</span></span><br><span class="line">      timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn();</span><br><span class="line">      &#125;, threshHold)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mounsemove = throttle(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.pageX, e.pageY);</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>exports和module.exports的区别</title>
      <link href="/blog/2019/08/31/exports%E5%92%8Cmodule.exports%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2019/08/31/exports%E5%92%8Cmodule.exports%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用 <strong>require</strong> 时，<strong>exports</strong> 和 <strong>module.exports</strong> 的区别</p></blockquote><ol><li>require:</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>. commonjs 规范</span><br><span class="line"><span class="selector-tag">b</span>. require 缓存策略</span><br><span class="line">c. 同步异步</span><br></pre></td></tr></table></figure><ol start="2"><li>module</li></ol><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. has <span class="keyword">property</span>: <span class="keyword">exports</span>(<span class="keyword">type</span>: <span class="keyword">Object</span>)</span><br><span class="line">b. <span class="keyword">exports</span> 只是 module.<span class="keyword">exports</span> 的引用</span><br></pre></td></tr></table></figure><a id="more"></a><ol start="3"><li>实例</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//koala.js</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'程序员成长指北'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>.exports); <span class="comment">//能打印出结果为：&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(exports); <span class="comment">//能打印出结果为：&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">exports.a = <span class="string">'程序员成长指北哦哦'</span>; <span class="comment">//这里辛苦劳作帮 module.exports 的内容给改成 &#123;a : '程序员成长指北哦哦'&#125;</span></span><br><span class="line"></span><br><span class="line">exports = <span class="string">'指向其他内存区'</span>; <span class="comment">//这里把exports的指向指走</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'/koala'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 打印为 &#123;a : '程序员成长指北哦哦'&#125;</span></span><br></pre></td></tr></table></figure><p>require 导出的内容是 module.exports 的指向的内存块内容，并不是 exports 的。 简而言之，区分他们之间的区别就是 exports 只是 module.exports 的引用，辅助后者添加内容用的。用内存指向的方式更好理解。</p><p>上面的代码等价于:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = somethings</span><br><span class="line"><span class="keyword">exports</span> = <span class="keyword">module</span>.<span class="keyword">exports</span></span><br></pre></td></tr></table></figure><p>复制代码原理很简单，即 module.exports 指向新的对象时，exports 断开了与 module.exports 的引用，那么通过 exports = module.exports 让 exports 重新指向 module.exports 即可。</p><p>参考文章：<a href="https://juejin.im/post/5d5639c7e51d453b5c1218b4" target="_blank" rel="noopener">https://juejin.im/post/5d5639c7e51d453b5c1218b4</a></p>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么const在&#39;for...in&#39;循环中起作用，而普通&#39;for&#39;循环中不起作用。</title>
      <link href="/blog/2019/06/22/ES6%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E&amp;%E4%B8%8D%E5%90%8CFor%E5%BE%AA%E7%8E%AF%E4%B8%ADconst%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2019/06/22/ES6%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E&amp;%E4%B8%8D%E5%90%8CFor%E5%BE%AA%E7%8E%AF%E4%B8%ADconst%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近写代码，在调ESLint时，发现<strong>const</strong>在for…in循环中，和普通for循环中，有一些不同。</p></blockquote><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ul><li><p>在传统的<strong>JavaScript</strong>中（非ES6），我们使用的是<strong>var</strong>关键字来做变量声明。不过其定义的变量存在：<strong>没有块级作用域</strong>，<strong>存在变量提升</strong>，<strong>可重复声明</strong>，<strong>全局变量会自动添加全局window对象下</strong>，<strong>提前装载</strong>等不足。</p></li><li><p>因此在ES6中，提供了两个新的声明变量的关键字：<strong>let</strong>和<strong>const</strong>，三者之间，存在着一些不同。</p></li><li><p>这里先通过对比三者的一些区别，来开始这个主题。</p></li></ul><a id="more"></a><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>let使用场景：变量，替代var</li><li>const使用场景：常量、声明匿名函数和箭头函数时。</li></ul><h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><ul><li>let可以先声明变量，稍后赋值。const声明后必须马上赋值，否则会报错。</li><li>const 简单类型的常量，一旦声明不可更改。复杂类型（对象，数组等）等指向指针的地址不能更改，内部数据可以改。</li></ul><h2 id="普通for循环中，var的行为："><a href="#普通for循环中，var的行为：" class="headerlink" title="普通for循环中，var的行为："></a>普通for循环中，var的行为：</h2><p><img src="/blog/assets/image/varLoop.jpg" alt="&#39;var loop&#39;"></p><ul><li>从上图可以看到，<strong>var</strong>声明的变量循环，变量<strong>i</strong>在循环体的外部，依然能访问的到。</li><li>在大多数时候，我们希望把<strong>i</strong>变量限制在<strong>{}</strong>的局部作用域中。而不是全局的window中。</li></ul><h2 id="普通for循环中，let的行为："><a href="#普通for循环中，let的行为：" class="headerlink" title="普通for循环中，let的行为："></a>普通for循环中，let的行为：</h2><p><img src="/blog/assets/image/letLoop.jpg" alt="&#39;let loop&#39;"></p><ul><li>从上图可以看到，<strong>let</strong>声明的变量循环，变量<strong>j</strong>在循环体的外部，访问会报错，变量<strong>j</strong>被限制在块级作用域内。</li><li>这样意味着，只能在其声明的<strong>块{}</strong>内部访问到。</li></ul><h2 id="普通for循环中，const的行为："><a href="#普通for循环中，const的行为：" class="headerlink" title="普通for循环中，const的行为："></a>普通for循环中，const的行为：</h2><ul><li>在上面已经说明了const的特殊之处，它定义的变量是不能重新分配或重新声明的常量。</li><li>由于这个原因，它是所有3个声明语句中<strong>最安全</strong>的选择。</li><li>下图为const声明变量的for循环。</li></ul><p><img src="/blog/assets/image/constLoop.jpg" alt="&#39;const loop&#39;"></p><ul><li>它只执行了一次循环，随即出现了报错。</li><li>在传统的for循环中，迭代器只在操作开始时声明一次，所以这里是使用let的好地方!</li></ul><h2 id="ESLint报错-for…of-or-for…in-循环中推荐使用const声明变量"><a href="#ESLint报错-for…of-or-for…in-循环中推荐使用const声明变量" class="headerlink" title="ESLint报错 for…of or for…in 循环中推荐使用const声明变量"></a>ESLint报错 <strong>for…of</strong> or <strong>for…in</strong> 循环中推荐使用const声明变量</h2><h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><p><img src="/blog/assets/image/constInLoop.jpg" alt="&#39;const in loop&#39;"></p><ul><li>如上图，使用<strong>for…in</strong>的方式循环使用<strong>const</strong>声明变量是可以的！</li><li>在深入检查这些<strong>for…in</strong>循环类型之后，似乎它们在每次循环中都创建了一个新的块范围。这将意味着每个新索引实际上是一个新范围内的新变量，这样我们的<strong>常量</strong>永远不会被重新分配。</li></ul><h3 id="for…in-let"><a href="#for…in-let" class="headerlink" title="for…in (let)"></a>for…in (let)</h3><p><img src="/blog/assets/image/letInLoop.jpg" alt="&#39;let in loop&#39;"></p><ul><li>如上图，虽然迭代器每次在循环结束时乘以2，但是在下一次执行时，打印的索引只是我们循环遍历的数组中的下一个连续索引。但是在索引轮询结束后，函数块返回6(最后一个索引3乘以2)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中，v-if和v-show的区别.md</title>
      <link href="/blog/2019/06/13/Vue%E4%B8%AD%EF%BC%8Cv-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2019/06/13/Vue%E4%B8%AD%EF%BC%8Cv-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if:"></a>v-if:</h2></blockquote><ul><li>v-if用在<strong>条件性地渲染</strong>一块内容，这块内容只会在指令的表达式返回的值为<strong>truthy</strong>时，才会被执行渲染。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span> v-<span class="keyword">if</span>=<span class="string">"awesome"</span>&gt;Vue is awesome!&lt;/h1&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>也可以用 v-else 添加一个“else 块”：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span> v-<span class="keyword">if</span>=<span class="string">"awesome"</span>&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">&lt;<span class="selector-tag">h1</span> v-<span class="keyword">else</span>&gt;Oh no 😢&lt;/h1&gt;</span><br></pre></td></tr></table></figure><ul><li>在template中，使用v-if 条件渲染分组</li></ul><p>因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 <template> 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 <template> 元素</template></template></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="v-else、v-else-if"><a href="#v-else、v-else-if" class="headerlink" title="v-else、v-else-if"></a>v-else、v-else-if</h2><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">if</span>=<span class="string">"type === 'A'"</span>&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"type === 'B'"</span>&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"type === 'C'"</span>&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">else</span>&gt;</span><br><span class="line">  <span class="keyword">Not</span> A/B/C</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><ul><li><p>v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。</p></li><li><p>用 key 管理可复用的元素：Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code>不会被替换掉——仅仅是替换了它的placeholder。</p></li><li><p>Vue提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的<strong>key</strong>属性即可：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>现在，每次切换时，输入框都将被重新渲染。</p></li><li><p>注意，<label> 元素仍然会被高效地复用，因为它们没有添加 key 属性。</label></p></li></ul><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><ul><li>另一个用于根据条件展示元素的选项是<strong>v-show</strong>指令。用法大致一样：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不同的是带有<strong>v-show</strong>的元素始终会被渲染并保留在<strong>DOM</strong>中。<strong>v-show</strong>只是简单地切换元素的CSS属性<strong>display</strong>。</p><p>注意：<strong>v-show</strong>不支持<code>&lt;template&gt;</code>元素，也不支持<strong>v-else</strong>。</p><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h2><ul><li><p><strong>v-if</strong>是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p></li><li><p><strong>v-if</strong>也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p></li><li><p>相比之下，<strong>v-show</strong>就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于CSS进行切换。</p></li><li><p>一般来说<strong>v-if</strong>有更高的切换开销，而<strong>v-show</strong>有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用<strong>v-show</strong>较好；如果在运行时条件很少改变，则使用<strong>v-if</strong>较好。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的工作原理及JS的运行机制</title>
      <link href="/blog/2019/06/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8AJS%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2019/06/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8AJS%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>浏览器的工作原理及JS的运行机制。</p></blockquote><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ul><li>浏览器是多进程的</li><li>梳理浏览器内核中线程之间的关系</li><li>浏览器渲染流程</li><li>从Event Loop谈JS的运行机制</li><li>事件循环进阶：macrotask与microtask</li><li>浏览器的安全</li></ul><h2 id="宏观视角下的浏览器"><a href="#宏观视角下的浏览器" class="headerlink" title="宏观视角下的浏览器"></a>宏观视角下的浏览器</h2><h3 id="Chrome架构：仅仅打开一个页面，为什么有多个进程？"><a href="#Chrome架构：仅仅打开一个页面，为什么有多个进程？" class="headerlink" title="Chrome架构：仅仅打开一个页面，为什么有多个进程？"></a>Chrome架构：仅仅打开一个页面，为什么有多个进程？</h3><a id="more"></a><p>现代浏览器使用的都是多进程架构，打开一个网页时最少有4个进程：</p><ol><li><p>Browser进程（主进程）：</p><ul><li>浏览器的界面显示，及用户交互（当前页面的前进后退）。</li><li>其他页面的管理: 创建、销毁其他页面等。</li><li>页面的Render渲染。</li><li>网络资源的管理，下载等。</li></ul></li><li><p>网络进程：</p><ul><li>主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li></ul></li><li><p>Renderer进程（渲染进程）：</p><ul><li>核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个Renderer进程。出于安全考虑，Renderer进程都是运行在沙箱模式下。</li></ul></li><li><p>GPU进程：</p><ul><li>Chrome 刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了GPU进程。</li></ul></li><li><p>页面进程：</p><ul><li><p>每打开一个页面，都会开启一个进程。</p><p>注：Chrome中，多个空的tab页会合并为一个进程。</p></li></ul></li><li><p>插件进程：</p><ul><li>每个浏览器插件都是一个进程，考虑到插件易崩溃，所以单独进程。</li></ul></li></ol><p>参考图：</p><p><img src="/blog/assets/image/process.png" alt></p><h3 id="多进程的优势？"><a href="#多进程的优势？" class="headerlink" title="多进程的优势？"></a>多进程的优势？</h3><ul><li><p>单个页面或第三方插件<strong>Crash</strong>，不会影响整个浏览器。</p></li><li><p>充分利用设备<strong>多核</strong>优势。</p></li><li><p>方便使用沙盒模型隔离插件等进程，提高稳定性。</p></li></ul><h3 id="HTTP请求流程：为什么很多网站第二次打开会快很多？"><a href="#HTTP请求流程：为什么很多网站第二次打开会快很多？" class="headerlink" title="HTTP请求流程：为什么很多网站第二次打开会快很多？"></a>HTTP请求流程：为什么很多网站第二次打开会快很多？</h3><ul><li>DNS缓存</li><li>页面资源缓存</li></ul><p>详细供参考链接：<a href="https://zhuanlan.zhihu.com/p/38240894" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38240894</a></p><h3 id="导航流程：从输入URL到页面展示，中间发生了什么？"><a href="#导航流程：从输入URL到页面展示，中间发生了什么？" class="headerlink" title="导航流程：从输入URL到页面展示，中间发生了什么？"></a>导航流程：从输入URL到页面展示，中间发生了什么？</h3><p>简化版：</p><ul><li><p>浏览器根据DNS服务器得到域名的IP地址。</p></li><li><p>向该IP地址的服务器发起HTTP请求。</p></li><li><p>服务器收到、处理、并返回HTTP请求。</p></li><li><p>浏览器得到返回内容，渲染流程开始。</p></li></ul><p>详细供参考链接：<a href="https://zhuanlan.zhihu.com/p/23155051" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23155051</a></p><h2 id="浏览器内核（即Renderer进程）-重点"><a href="#浏览器内核（即Renderer进程）-重点" class="headerlink" title="浏览器内核（即Renderer进程）- 重点"></a>浏览器内核（即Renderer进程）- 重点</h2><p>大多时候，对于前端开发来讲，最重要、最需要清楚的就是<strong>浏览器的渲染，即Renderer进程：</strong></p><ul><li><p>页面的渲染，JS的执行，以及事件的轮询。</p></li><li><p>浏览器Renderer进程，即Renderer进程是<strong>多线程的</strong>。</p></li></ul><h3 id="主要包含哪些线程："><a href="#主要包含哪些线程：" class="headerlink" title="主要包含哪些线程："></a>主要包含哪些线程：</h3><ol><li><p>GUI渲染线程</p><ul><li>负责浏览器的界面渲染。</li></ul></li><li><p>JS引擎线程</p><ul><li><p>负责JavaScript脚本的处理和解析。（例如Chrome V8引擎）。</p></li><li><p>等待着任务队列中任务的到来，然后加以处理，一个Tab页只有一个JS线程。</p></li></ul></li><li><p>事件触发线程</p><ul><li><p>归属于浏览器而不是JS引擎，用来事件轮询。</p></li><li><p>当<strong>JS引擎</strong>执行代码块，例如<strong>用户点击</strong>，<strong>定时器</strong>，<strong>网络请求</strong>等异步Function。会将此任务添加到<strong>事件队列</strong>（即事件触发线程）中。</p></li><li><p>当对应的事件符合触发的条件，被触发时，事件线程会将其添加到事件队列的队尾，等待<strong>JS引擎</strong>的处理。</p></li></ul></li><li><p>定时器触发线程 <strong>setTimeout</strong>和<strong>setInterval</strong></p><ul><li><p>定时器不是由JS引擎计时的。因为JS引擎是单线程的，如果处于阻塞状态会影响计时的准确性。</p></li><li><p>为了保证计时的准确性，就单独起一个线程，来做计时，计时完毕后，排在事件队列中，等待JS引擎空闲后执行。</p></li></ul></li><li><p>HTTP网络请求线程</p><ul><li><p>在<strong>XMLHttpRequest</strong>，连接后，起一个新线程，触发请求。</p></li><li><p>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JS引擎执行。</p></li></ul></li></ol><h3 id="HTML，CSS，JavaScript是如何变成页面的？"><a href="#HTML，CSS，JavaScript是如何变成页面的？" class="headerlink" title="HTML，CSS，JavaScript是如何变成页面的？"></a>HTML，CSS，JavaScript是如何变成页面的？</h3><ol><li>根据HTML生成DOM Tree。</li><li>根据CSS生成CSSOM。</li><li>根据DOM Tree和CSSOM生成Render Tree。</li><li>根据Render Tree开始渲染和展示。</li><li>遇见<strong>&lt;script&gt;</strong>标签，执行，并阻塞渲染。（与JS引擎线程互斥）</li></ol><p>参考图：<img src="/blog/assets/image/render-page.png" alt="Render process"></p><h3 id="WebWorker（HTML5-API）（简略）"><a href="#WebWorker（HTML5-API）（简略）" class="headerlink" title="WebWorker（HTML5 API）（简略）"></a>WebWorker（HTML5 API）（简略）</h3><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li><p>比如页面中包含耗时较大的算法代码时，就会阻塞线程影响浏览器渲染等。这时候就可把比较耗时的代码，放到<strong>WebWorker</strong>(另一个线程)中执行。</p></li><li><p><strong>new Worker()</strong></p></li><li><p>流程：</p><ul><li><p>首先，JS引擎向浏览器申请开一个子线程创建worker线程（其本身不能操作DOM）</p></li><li><p>JS引擎线程与Worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</p></li><li><p>待计算出结果后，将结果通信给JS主线程。</p></li></ul></li></ul><p>注：WebWorker是<strong>当前页面专有</strong>的。</p><p>详细供参考链接：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers</a></p><h3 id="SharedWorker（简略）"><a href="#SharedWorker（简略）" class="headerlink" title="SharedWorker（简略）"></a>SharedWorker（简略）</h3><h4 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li><p>多个标签页、iframe之间的通信。</p></li><li><p><strong>new SharedWorker(‘worker.js’)</strong></p></li><li><p>前提都是同源的(相同的协议，域名和端口)</p></li></ul><p>注：SharedWorker是浏览器所有页面共享的，它不隶属于某个Renderer进程，可以为多个Renderer进程共享。</p><p>详细供参考链接：<a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker</a></p><h2 id="Browser进程与Renderer进程的通信具体实例"><a href="#Browser进程与Renderer进程的通信具体实例" class="headerlink" title="Browser进程与Renderer进程的通信具体实例"></a>Browser进程与Renderer进程的通信具体实例</h2><ol><li><p>当我们打开<strong>任务管理器</strong>后，新打开一个浏览器后，<strong>任务管理器</strong>中相应的增加了两个进程：</p><ul><li><p>主控进程</p></li><li><p>tab页面的Renderer进程</p></li></ul></li><li><p>tab页非空白页的前提下，整个主要的渲染过程如下：</p><ul><li><p>Browser进程收到请求，先要获取页面内容，然后将RendererHost接口传递给Renderer进程。</p></li><li><p>Renderer进程相应的接口收到消息，<strong>处理后，交给渲染线程</strong>，开始渲染：</p></li><li><p>渲染线程收到收到请求，加载并渲染网页，期间可能需要Browser进程和GPU进程帮助渲染。</p></li><li><p>期间，还可能会有JS线程进程DOM操作（操作可能会导致回流、重绘）。</p></li><li><p>最后，<strong>渲染结果</strong>将传给Browser进程。</p></li><li><p>Browser进程收到结果并将结果绘制出来。</p></li></ul></li></ol><p>通信的过程参考图：<br><img src="/blog/assets/image/browser-communication.png" alt="&#39;Browser communication&#39;"></p><h2 id="V8工作原理（简略）"><a href="#V8工作原理（简略）" class="headerlink" title="V8工作原理（简略）"></a>V8工作原理（简略）</h2><h3 id="栈空间和堆空间：数据是如何存储的？"><a href="#栈空间和堆空间：数据是如何存储的？" class="headerlink" title="栈空间和堆空间：数据是如何存储的？"></a>栈空间和堆空间：数据是如何存储的？</h3><ul><li><p>在JavaScript的执行过程中，主要有三种类型内存空间：代码空间、栈空间、堆空间。</p></li><li><p>原始类型的数据值都是直接保存在栈中的，引用类型的值都是保存在堆空间中的。</p></li><li><p>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。堆空间很大，能存放很多大的数据。</p></li><li><p>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p></li></ul><h3 id="垃圾回收：垃圾数据是如何自动回收的？"><a href="#垃圾回收：垃圾数据是如何自动回收的？" class="headerlink" title="垃圾回收：垃圾数据是如何自动回收的？"></a>垃圾回收：垃圾数据是如何自动回收的？</h3><p>对一些不需要的数据，我们称之为垃圾数据，由于内存是有限的，为了释放内存，我们需要对这么垃圾数据进行回收：</p><p>详细供参考链接：<a href="https://zhuanlan.zhihu.com/p/23992332" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/23992332</a></p><h3 id="编译器和解释器：V8中是如何执行一段JS代码的？"><a href="#编译器和解释器：V8中是如何执行一段JS代码的？" class="headerlink" title="编译器和解释器：V8中是如何执行一段JS代码的？"></a>编译器和解释器：V8中是如何执行一段JS代码的？</h3><p>详细供参考链接：<a href="https://juejin.im/post/5dc4d823f265da4d4c202d3b" target="_blank" rel="noopener">https://juejin.im/post/5dc4d823f265da4d4c202d3b</a></p><h2 id="浏览器中的JS运行机制-重点"><a href="#浏览器中的JS运行机制-重点" class="headerlink" title="浏览器中的JS运行机制 - 重点"></a>浏览器中的JS运行机制 - 重点</h2><p>当页面渲染首次完毕之后，就到了JS引擎线程运行的机制分析：</p><p>这里主要从EventLoop来说一下JS的执行。</p><h3 id="几个概念："><a href="#几个概念：" class="headerlink" title="几个概念："></a>几个概念：</h3><ul><li><p>JS分同步任务和异步任务。</p></li><li><p>同步任务在<strong>主线程</strong>上执行，会形成一个<strong>执行栈</strong>。</p></li><li><p>另外，还有一个<strong>事件触发线程</strong>，负责<strong>任务队列</strong>，只要异步任务有了运行结果，就在任务队列中添加一个事件。</p></li><li><p>一旦<strong>执行栈</strong>中的同步任务全部执行完毕，即此时JS引擎线程空闲，就会开始读取任务队列，将可运行的异步任务加到执行栈中，开始执行。</p></li></ul><p>流程如图：<br>    <img src="/blog/assets/image/evt.png" alt="&#39;Event process img&#39;"></p><h3 id="定时器："><a href="#定时器：" class="headerlink" title="定时器："></a>定时器：</h3><p>上边的EventLoop机制的核心就是：<strong>JS引擎线程</strong>和<strong>事件触发线程</strong>。</p><ul><li>在浏览器中，定时器不是JS引擎线程来控制的，而是由浏览器单独起一个定时器线程来计时的。</li></ul><p><strong>单独起定时器线程的原因：</strong></p><ul><li>因为JavaScript引擎是单线程的，一旦其正处于阻塞状态，会影响计时的准确性，所以浏览器单独起一个线程来做计时。</li></ul><p><strong>什么时候会用到定时器线程：</strong></p><ul><li>当使用<strong>setTimeout</strong>或<strong>setInterval</strong>的时候，需要用到定时器线程计时，待计时完成后，将相应事件推入事件队列中，排队等待<strong>主线程</strong>执行。</li></ul><p>eg. </p><pre><code>setTimeout(() =&gt; {    console.log(&apos;hello!&apos;);}, 0);console.log(&apos;begin&apos;);</code></pre><p><strong>注：</strong></p><p>执行结果：先begin，后hello。</p><p>虽然本身是0ms，随即推入事件队列，但在W3C标准中，低于4ms的间隔，按4ms算。</p><p><strong>setTimeout代替setInterval：</strong></p><p>用setTimeout模拟setInterval，和直接使用setInterval是有区别的，原因：</p><ul><li><p>setTimeout会在每次计时完毕后，就会去执行(有一定误差)，执行一段时间后才会继续setTimeout。</p></li><li><p>而setInterval每次都精确的隔一段时间推入一个事件。但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了，这样就会导致累积效应。导致定时器<strong>连续运行多次</strong>，而中间<strong>没有时间间隔</strong>。</p></li></ul><p>注：有时候<strong>setTimeout</strong>不能准确按照制定的延时时间执行，就是因为可能在它排在任务队列中时，主线程不是空闲状态，正在执行其它任务，所以会造成误差。</p><h3 id="macrotask与microtask："><a href="#macrotask与microtask：" class="headerlink" title="macrotask与microtask："></a><strong>macrotask与microtask：</strong></h3><h4 id="JS任务类型分两种：macrotask-宏任务-与microtask-微任务"><a href="#JS任务类型分两种：macrotask-宏任务-与microtask-微任务" class="headerlink" title="JS任务类型分两种：macrotask(宏任务)与microtask(微任务)"></a>JS任务类型分两种：<strong>macrotask(宏任务)与microtask(微任务)</strong></h4><ol><li><p>macrotask - task:</p><ul><li><p>每次执行栈执行的代码就是一个宏任务，包括每次从事件队列中获取一个事件回调并放到执行栈中执行。</p></li><li><p>每个task直到执行完毕，期间不会执行其他任务。</p></li><li><p>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;…）</p></li></ul></li><li><p>microtask - jobs:</p><ul><li><p>在当前<strong>task</strong>执行完毕后，立即执行（在当前task任务后，下一个task之前，在渲染之前）。</p></li><li><p>所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染。</p></li><li><p>在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）。</p></li></ul></li></ol><p><strong>注：</strong></p><ul><li><p>宏任务微任务，简单来说，都是异步代码，一般情况下，一个宏任务内部总是先<strong>按顺序执行同步代码</strong>，之后再执行该宏任务中的微任务，等到都执行完毕，再进入下一个宏任务。</p></li><li><p><strong>macrotask（宏任务）：</strong>script标签包含的code、<strong>setTimeout</strong>、<strong>setInterval</strong>、<strong>setImmediately</strong>、<strong>I/O</strong>等。（可以看到，事件队列中的每一个事件都是一个macrotask）</p></li><li><p><strong>microtask（微任务）：</strong> <strong>MutationObserver</strong>，<strong>Promise</strong>，<strong>process.nextTick</strong>等<br>(浏览器中的优先级：process.nextTick &gt; Promise &gt; MutationObserver)。</p></li></ul><p>总结：</p><ul><li><p>所有宏任务都是放在一个事件队列中的，而这个队列由事件触发线程维护。</p></li><li><p>所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行。</p></li></ul><p>如图：</p><p><img src="/blog/assets/image/task.png" alt="&#39;task img&#39;"></p><p>一段代码：</p><pre><code>async function async1() {    console.log(1)    const result = await async2();    console.log(3)}async function async2() {    console.log(2);}Promise.resolve().then(() =&gt; {    console.log(4)})setTimeout(() =&gt; {    console.log(5)}, 0)async1();console.log(6);</code></pre><h2 id="浏览器安全（简略）"><a href="#浏览器安全（简略）" class="headerlink" title="浏览器安全（简略）"></a>浏览器安全（简略）</h2><ul><li><p>同源策略：为什么XMLHttpRequest不能跨域请求资源？</p><ul><li>同源策略会隔离不同源的 DOM、页面数据和网络通信，进而实现Web页面的安全性</li></ul></li><li><p>跨域通信：</p><ol><li><p>通过jsonp跨域</p></li><li><p>document.domain + iframe跨域</p></li><li><p>location.hash + iframe</p></li><li><p>window.name + iframe跨域</p></li><li><p>PostMessage跨域</p></li><li><p>跨域资源共享（CORS）</p></li><li><p>Nginx代理跨域</p></li><li><p>Nodejs中间件代理跨域</p></li><li><p>WebSocket协议跨域</p><p>详细供参考链接：<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1" target="_blank" rel="noopener">https://juejin.im/post/5c23993de51d457b8c1f4ee1</a></p></li></ol></li><li><p>网络攻击：</p><ul><li><p>XSS(Cross Site Scripting - 跨站脚本攻击)：</p><ul><li><p>场景实例：</p><ul><li><p>在新浪博客写了一篇文章，同时偷偷插入一段<strong>&lt;script&gt;</strong></p></li><li><p>在攻击代码中，获取cookie，发送到自己的服务器。</p></li><li><p>发布博客，有人查看博客内容。</p></li><li><p>则查看者的cookie发送到攻击者的服务器。</p></li></ul></li></ul></li><li><p>CSRF(Cross-site request forgery - 跨站请求伪造)：</p><ul><li><p>场景实例：</p><ul><li><p>你已登录一个购物网站。</p></li><li><p>该网站的付费接口是xxx.com/pay?id=250，但没有验证。</p></li><li><p>然后你收到一封邮件，隐藏着&lt;img src=xxx.com/pay?id=250&gt;</p></li><li><p>查看邮件的时候，就已经悄悄购买了。</p></li></ul></li></ul></li></ul></li><li><p>如何避免：</p><ul><li><p>XSS：</p><ol><li><p>HttpOnly 防止劫取 Cookie</p></li><li><p>不要相信用户的任何输入。</p></li><li><p>Server端做输出检查。</p></li></ol></li><li><p>CSRF：</p><ol><li><p>增加指纹，密码，短信验证码等。</p></li><li><p>增加Token验证。</p></li></ol></li><li><p>HTTPS - 让数据传输更安全。</p></li></ul></li></ul><p>详细供参考链接：<a href="https://juejin.im/entry/5b4b56fd5188251b1a7b2ac1" target="_blank" rel="noopener">https://juejin.im/entry/5b4b56fd5188251b1a7b2ac1</a></p><p>本文其他参考链接：</p><p><a href="https://time.geekbang.org/column/intro/216" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/216</a><br><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7" target="_blank" rel="noopener">https://juejin.im/post/5a6547d0f265da3e283a1df7</a><br><a href="https://juejin.im/post/5dc12da8f265da4cfb512db0" target="_blank" rel="noopener">https://juejin.im/post/5dc12da8f265da4cfb512db0</a></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中，计算属性vs方法vs侦听属性</title>
      <link href="/blog/2019/03/21/Vue%E4%B8%AD%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7vs%E6%96%B9%E6%B3%95vs%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/"/>
      <url>/blog/2019/03/21/Vue%E4%B8%AD%EF%BC%8C%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7vs%E6%96%B9%E6%B3%95vs%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>template 中，内嵌的表达式，可以添加简单的运算，以便动态绑定显示一些值。</p></blockquote><h2 id="计算属性："><a href="#计算属性：" class="headerlink" title="计算属性："></a>计算属性：</h2><p>当 Vue.js 模板(template)中的内嵌表达式，逻辑较为复杂时，会使模板过重，且难以维护。</p><p>例如：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> id=<span class="string">"example"</span>&gt;</span><br><span class="line">  &#123;&#123;message.split(<span class="string">''</span>).<span class="keyword">reverse</span>().join(<span class="string">''</span>)&#125;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这时，模板中已经不算是简单的生命是逻辑，这里更优的做法，是将属性的计算方法，放到 computed 属性中。</p><h3 id="基础例子："><a href="#基础例子：" class="headerlink" title="基础例子："></a>基础例子：</h3><p><strong>template:</strong></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "</span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml">"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "</span><span class="template-variable">&#123;&#123; reversedMessage &#125;&#125;</span><span class="xml">"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>js:</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123; // <span class="keyword">vm</span> = <span class="keyword">view</span> model</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span> <span class="string">'#example'</span>,</span><br><span class="line">  dat<span class="variable">a:</span> &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">      // `this` 指向 <span class="keyword">vm</span> 实例</span><br><span class="line">      <span class="keyword">return</span> this.message.<span class="keyword">split</span>(<span class="string">''</span>).<span class="built_in">reverse</span>().<span class="keyword">join</span>(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p>Original message: <strong>“Hello”</strong></p><p>Computed reversed message: <strong>“olleH”</strong></p><h2 id="2-计算属性-vs-方法："><a href="#2-计算属性-vs-方法：" class="headerlink" title="2. 计算属性 vs 方法："></a>2. 计算属性 vs 方法：</h2><p>上边的这个例子，通过表达式的形式，在<strong>methods</strong>中同样可以实现。</p><p><strong>template:</strong></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: "</span><span class="template-variable">&#123;&#123; reversedMessage() &#125;&#125;</span><span class="xml">"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>js:</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.<span class="built_in">split</span>(<span class="string">''</span>).<span class="built_in">reverse</span>().<span class="built_in">join</span>(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种的实现方法，最后的结果是相同的。</p><h3 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h3><p>计算属性是基于它们的<strong>响应式依赖</strong>进行<strong>缓存</strong>的，只在相关响应式依赖发生改变时，才会重新求值。</p><p>这就意味着，只要上边例子中的 message 没有发生改变，多次访问 reversed 计算属性，会<strong>立即返回</strong>之前的计算结果，而不会再次执行函数。</p><h3 id="注：Date-now"><a href="#注：Date-now" class="headerlink" title="注：Date.now()"></a>注：Date.now()</h3><p>这也同样意味着，下面的计算属性将不再更新，因为<strong>Date.now()</strong>不是响应式依赖：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">computed</span>: &#123;</span><br><span class="line">  <span class="attribute">now</span>: function () &#123;</span><br><span class="line">    return Date.<span class="built_in">now</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p><h3 id="为什么要缓存？"><a href="#为什么要缓存？" class="headerlink" title="为什么要缓存？"></a>为什么要缓存？</h3><ul><li>原因：当我们有一个性能开销比较大的计算属性<strong>A</strong>，它需要遍历一个巨大的数组并做大量的运算。然后我们可能有其他的计算属性依赖于<strong>A</strong>。<br>如果这种情况下<strong>没有缓存</strong>，我们将不可避免地多次执行<strong>A</strong>的 getter！</li></ul><p>反之，如果不希望缓存的场景下，可以用方法替代。</p><h2 id="计算属性-vs-侦听属性："><a href="#计算属性-vs-侦听属性：" class="headerlink" title="计算属性 vs 侦听属性："></a>计算属性 vs 侦听属性：</h2><p>Vue 中提供了一种更通用的方式来观察和响应 VUe 实例上的数据变动：<strong>侦听属性</strong>。</p><p>当有一些数据，需要随着他的数据变动而改变时，很容易就滥用<strong>watch</strong>。然而，通常更好的做法是：使用计算属性而不是命令式 watch 回调。</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p><strong>template:</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"demo"</span>&gt;&#123;&#123; fullName &#125;&#125;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>js:</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = new Vue(&#123;</span><br><span class="line">el: <span class="string">'#demo'</span>,</span><br><span class="line"><span class="keyword">data</span>: &#123;</span><br><span class="line">  firstName: <span class="string">'Foo'</span>,</span><br><span class="line">  lastName: <span class="string">'Bar'</span>,</span><br><span class="line">  fullName: <span class="string">'Foo Bar'</span></span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  firstName: function (<span class="keyword">val</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fullName = <span class="keyword">val</span> + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">  &#125;,</span><br><span class="line">  lastName: function (<span class="keyword">val</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">val</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上边的代码是命令式且重复的，将它与计算属性的版本进行比较：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="计算属性的setter："><a href="#计算属性的setter：" class="headerlink" title="计算属性的setter："></a>计算属性的setter：</h2><p>计算属性默认只有<strong>getter</strong>，不过在需要时也可以提供一个<strong>setter</strong>：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span> <span class="params">(newValue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>现在再运行vm.fullName = ‘xxx yy’ 时，setter会被调用，同时vm.firstName 和 vm.lastName 也会相应地被更新。</p><h2 id="侦听器："><a href="#侦听器：" class="headerlink" title="侦听器："></a>侦听器：</h2><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么Vue通过<strong>watch</strong>属性提供了一个更通用的方法，来响应数据的变化。</p><ul><li>使用场景：当需要在数据变化时，执行<strong>异步或开销较大</strong>的操作时，使用<strong>watch</strong>是更优的。</li></ul><p>例如：</p><p><strong>template:</strong></p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"watch-example"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    Ask a yes/no question:</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; answer &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>js:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el: <span class="string">'#watch-example'</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="actionscript">    question: <span class="string">''</span>,</span></span><br><span class="line"><span class="vbscript">    answer: <span class="comment">'I cannot give you an answer until you ask a question!'</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span><br><span class="line"><span class="actionscript">    question: <span class="function"><span class="keyword">function</span> <span class="params">(newQuestion, oldQuestion)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.debouncedGetAnswer()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.debouncedGetAnswer = _.debounce(<span class="keyword">this</span>.getAnswer, <span class="number">500</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="actionscript">    getAnswer: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span></span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span></span><br><span class="line"><span class="vbscript">      axios.<span class="keyword">get</span>(<span class="comment">'https://yesno.wtf/api')</span></span></span><br><span class="line"><span class="actionscript">        .then(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> </span>&#123;</span></span><br><span class="line"><span class="vbscript">          vm.answer = _.capitalize(<span class="built_in">response</span>.data.answer)</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="actionscript">        .catch(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，使用watch属性，允许我们执行<strong>请求一个API</strong>（异步操作），限制我们执行操作的频率，并在得到最终的结果前，设置<strong>中间状态</strong>。这些都是计算属性无法做到的。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>package.json中dependencies和devDependencies的区别</title>
      <link href="/blog/2019/03/12/package.json%E4%B8%ADdependencies%E5%92%8CdevDependencies%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2019/03/12/package.json%E4%B8%ADdependencies%E5%92%8CdevDependencies%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以前一直在纠结一个npm安装的包依赖管理的问题。是这样的：</p></blockquote><p>我们在使用包管理器安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，他们是：</p><a id="more"></a><p><code>--save-dev</code> / <code>--dev</code> 或 <code>--save</code></p><ol><li><p>dependencies: 依赖和附属的意思。</p></li><li><p>dev: develop（开发）的简写。</p><ul><li>它们的区别在 package.json 文件里面体现出来的就是，使用 –save-dev 安装的 插件，被写入到 devDependencies 域里面去，而使用 –save 安装的插件，则是被写入到 dependencies 区块里面去。</li></ul></li><li><p>package.json 文件里面的<strong>devDependencies</strong>和<strong>dependencies</strong>对象有什么区别呢？</p><ul><li><p>devDependencies: 里面的插件只用于开发环境，不用于生产环境，而<strong>dependencies</strong>是需要发布到生产环境的。</p></li><li><p>比如我们写一个项目要依赖于<strong>element-ui</strong>，没有这个包的依赖运行就会报错，这时候就把这个依赖写入dependencies。</p></li><li><p>而我们使用的一些构建工具比如glup、webpack这些只是在开发中使用的包，上线以后就和他们没关系了，就可以将它写入devDependencies中。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 包管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器中console.log()，出现&#39;value below was evaluated just now&#39;的情况</title>
      <link href="/blog/2019/02/13/value%20below%20was%20evaluated%20just%20now/"/>
      <url>/blog/2019/02/13/value%20below%20was%20evaluated%20just%20now/</url>
      
        <content type="html"><![CDATA[<blockquote><p>偶然一次，在浏览器控制台，使用console.log()打印调试代码的时候，发现这样一个现象：</p></blockquote><h2 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h2><p><img src="/blog/assets/image/value-null.png" alt="value-null"></p><a id="more"></a><p>对象/数组展开之前，是<code>{}</code>，但是展开之后，发现里面显示的是最终的输出结果。</p><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>chrome的解释是<code>&#39;Value below was evaluated just now&#39;</code>，后经查阅发现：</p><ul><li>当在控制台展开<code>console.log()</code>打印出来的数组（对象），若此时数组（对象）的数据已经发生了改变，那么则显示改变后最终的数据。</li></ul><p>注：Firefox下也有此现象。</p><p>参考链接：</p><p><a href="https://stackoverflow.com/questions/4057440/is-chromes-javascript-console-lazy-about-evaluating-arrays#comment4358029_4057440" target="_blank" rel="noopener">https://stackoverflow.com/questions/4057440/is-chromes-javascript-console-lazy-about-evaluating-arrays#comment4358029_4057440</a></p><p><a href="https://bugs.webkit.org/show_bug.cgi?id=35801" target="_blank" rel="noopener">https://bugs.webkit.org/show_bug.cgi?id=35801</a></p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新版Sublime Text3的Package Control打不开的问题</title>
      <link href="/blog/2019/01/05/%E6%96%B0%E7%89%88Sublime%20Text3%E7%9A%84Package%20Control%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2019/01/05/%E6%96%B0%E7%89%88Sublime%20Text3%E7%9A%84Package%20Control%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前一段时间电脑上的Sublime Text3 突然不太好用，索性就卸载重装了一个。</p></blockquote><blockquote><p>结果安装完后，准备安装需要用到的插件，结果发现<strong>Package Control</strong> 打不开。试过很多次依然打不开。之前从来没有遇到过这个问题。</p></blockquote><p>然后Google了一下，发现类似的问题很少出现，后来在Github的Sublime Text3官方问题区，找到了如何解决的方式。</p><p><strong>步骤如下：</strong></p><p>首先，在编辑器安装路径下，找到  <strong>PackageControl.sublime-settings</strong>文件，将<strong>debug</strong>设为<strong>true</strong>。<br><img src="https://github.com/Saturday24/notes/blob/master/image/sublime-text-debug.png?raw=true" alt></p><p>然后，打开编辑器的<strong>调试窗口</strong>，再次进行打开<strong>Package Control</strong> 的操作。</p><p>结果发现报错信息是：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">There are <span class="keyword">no</span> packages available <span class="keyword">for</span> installation - Package Control <span class="keyword">of</span> Sublime <span class="type">Text</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">Package Control: Unable <span class="keyword">to</span> download https://packagecontrol.io/channel_v3.json <span class="keyword">after</span> <span class="number">3</span> attempts</span><br></pre></td></tr></table></figure><a id="more"></a><p>就是安装插件的那个Package Control在需要拿到channel url下的地址，从而获取插件的配置项和依赖。</p><p>这里的<code>https://packagecontrol.io/channel_v3.json</code>，在打开SS后，在浏览器中能访问， 但是编辑器本身不支持https的路径，所以翻墙也拿不到。</p><p>所以只好在浏览器打开该地址，将该JSON文件的所有内容复制下来，自行在本地或者服务器中封装一个<strong>GET</strong>方式的<strong>API</strong>，然后在<strong>PackageControl.sublime-settings</strong>文件中，添加或修改<strong>channels</strong>中添加上墙内的API的地址即可。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"channels"</span>:</span><br><span class="line">[<span class="meta"></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://PATH/channel_v3.json"</span></span></span><br><span class="line"><span class="meta"></span>]</span><br></pre></td></tr></table></figure><p><strong>(注：此处的PATH指的封装的API的IP)</strong></p><p>(此处我是在服务器上开了一个端口，写了一个http的get请求的API。)</p>]]></content>
      
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH设置无密码和使用别名登录Linux服务器</title>
      <link href="/blog/2018/03/18/SSH%E8%AE%BE%E7%BD%AE%E6%97%A0%E5%AF%86%E7%A0%81%E5%92%8C%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D%E7%99%BB%E5%BD%95Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/blog/2018/03/18/SSH%E8%AE%BE%E7%BD%AE%E6%97%A0%E5%AF%86%E7%A0%81%E5%92%8C%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D%E7%99%BB%E5%BD%95Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在使用远程服务器的时候，经常需要本地使用<strong>ssh</strong>密码去登录，每次都需要去输入密码，很繁琐，后来学习了一下如何在本地使用<strong>无密码登录</strong>，特此记录，仅供参考。</p></blockquote><p><strong>步骤如下：</strong></p><ol><li>首先，拿到本机的.ssh下的公钥，若无则手动创建即可。</li></ol><p>进入.ssh目录 若无此目录，根目录下手动mkdir .ssh即可</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.ssh</span></span><br></pre></td></tr></table></figure><p>创建秘钥对，最后的-P即私钥密锁为空，免密登录用。</p><a id="more"></a><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="selector-tag">b</span> <span class="number">1024</span> -t rsa -f id_rsa -P <span class="string">""</span></span><br></pre></td></tr></table></figure><p>打开<strong>id_rsa.pub</strong>文件复制下来公钥</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cat</span> <span class="selector-tag">id_rsa</span><span class="selector-class">.pub</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>其次，ssh登录远程服务器，在根目录下，进入.ssh目录，若无，<strong>mkdir</strong>手动创建。</p></li><li><p>然后，在.ssh目录下打开或创建并打开authorized_keys文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">touch</span> <span class="string">authorized_key </span></span><br><span class="line"><span class="attr">vi</span> <span class="string">authorized_key</span></span><br></pre></td></tr></table></figure></li><li><p>最后将步骤1中的本地公钥粘贴到服务器的authorized_key上即可实现免密登录了。</p></li></ol><p>这时服务器上已经有了本地的公钥，即可在本地实现<strong>免密登录</strong>了:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">user</span>@<span class="keyword">xxx</span>.<span class="keyword">com</span></span><br></pre></td></tr></table></figure><p>这里也可以配置别名直接使用<strong>别名登录</strong>：</p><ol><li><p>进入.bash_profile文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~/</span><br><span class="line">vi <span class="string">.bash_profile</span></span><br></pre></td></tr></table></figure></li><li><p>添加启动别名</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">alias</span> startserver=<span class="string">'ssh user<span class="variable">@xxx</span>.com'</span></span><br></pre></td></tr></table></figure></li><li><p>重载.bash_profile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ol><p>正常情况下，这样就可以使用别名直接登录了。</p><h4 id="问题：但是Mac上安装了item2-zsh的话，每次新打开一个终端窗口，重载就会失效，需要重新执行重载命令。"><a href="#问题：但是Mac上安装了item2-zsh的话，每次新打开一个终端窗口，重载就会失效，需要重新执行重载命令。" class="headerlink" title="问题：但是Mac上安装了item2+zsh的话，每次新打开一个终端窗口，重载就会失效，需要重新执行重载命令。"></a>问题：但是Mac上安装了item2+zsh的话，每次新打开一个终端窗口，重载就会失效，需要重新执行重载命令。</h4><h4 id="原因：每次新打开窗口，zsh加载的都是-zshrc文件。"><a href="#原因：每次新打开窗口，zsh加载的都是-zshrc文件。" class="headerlink" title="原因：每次新打开窗口，zsh加载的都是 ~/.zshrc文件。"></a>原因：每次新打开窗口，zsh加载的都是 ~/.zshrc文件。</h4><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ol><li><p>进入.zshrc文件</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~<span class="string">/.zshrc</span></span><br></pre></td></tr></table></figure></li><li><p>将重载语句添加到.zshrc文件的中即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure></li></ol><p>注：windows版同理，拿到本机.ssh的公钥复制到远程服务器下即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Node.js Sequelize操作CentOS远程服务器的Mysql</title>
      <link href="/blog/2018/02/18/%E4%BD%BF%E7%94%A8Node.js%20Sequelize%E6%93%8D%E4%BD%9CCentOS%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84Mysql/"/>
      <url>/blog/2018/02/18/%E4%BD%BF%E7%94%A8Node.js%20Sequelize%E6%93%8D%E4%BD%9CCentOS%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84Mysql/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前端有时候也需要自己写后端以及数据库的代码，可能会使用Node.js作为服务端代码，并与数据库连接进行数据交互。</p></blockquote><p>其中，操作数据库部分，这里使用的<strong>mysql</strong>：这里可以直接使用mysql包提供的接口，缺点是编写的代码比较底层，而且在代码中使用<strong>SQL语句</strong>安全性较差。</p><h4 id="这里使用的方法是sequelize操作数据库。"><a href="#这里使用的方法是sequelize操作数据库。" class="headerlink" title="这里使用的方法是sequelize操作数据库。"></a>这里使用的方法是<strong>sequelize</strong>操作数据库。</h4><p>（学名为Node.JS的ORM框架，即把关系数据库的表结构映射到对象上）</p><h4 id="使用该框架，增删改查的都是JavaScript对象。"><a href="#使用该框架，增删改查的都是JavaScript对象。" class="headerlink" title="使用该框架，增删改查的都是JavaScript对象。"></a>使用该框架，增删改查的都是JavaScript对象。</h4><p>本文为使用Sequelize连接服务器上的Mysql。特此记录，仅供参考：</p><a id="more"></a><p><strong>步骤如下：</strong></p><ol><li>安装依赖</li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开终端进入项目的根目录</span></span><br><span class="line">npm install sequelize</span><br><span class="line"></span><br><span class="line"><span class="comment">// sequelize操作依赖于mysql2</span></span><br><span class="line">npm install mysql2</span><br></pre></td></tr></table></figure><ol start="2"><li>连接数据库</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> Sequelize = <span class="keyword">require</span>(<span class="string">'sequelize'</span>);</span><br><span class="line"><span class="comment">// 数据库名, mysql的用户名, 密码</span></span><br><span class="line"><span class="built_in">var</span> sequelize = <span class="literal">new</span> Sequelize(db_name, user_name, password, &#123;</span><br><span class="line">host: IP, <span class="comment">// 服务端地址，默认localhost</span></span><br><span class="line">port:<span class="string">'3306'</span>,</span><br><span class="line">  dialect: <span class="string">'mysql'</span>,</span><br><span class="line">  pool: &#123;   <span class="comment">//连接池设置</span></span><br><span class="line">    <span class="keyword">max</span>: <span class="number">5</span>, <span class="comment">//最大连接数</span></span><br><span class="line">    <span class="keyword">min</span>: <span class="number">0</span>, <span class="comment">//最小连接数</span></span><br><span class="line">    idle: <span class="number">10000</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="3"><li>测试连接</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequelize.authenticate().<span class="keyword">then</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"数据库连接成功"</span>);</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="params">(err)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//</span>数据库连接失败时打印输出</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>定义模型test，告诉Sequelize如何映射数据库表：</li></ol><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const test = sequelize.<span class="class"><span class="keyword">define</span></span>(<span class="string">'test'</span>, &#123;</span><br><span class="line">    id: &#123;</span><br><span class="line">        <span class="keyword">type</span>: Sequelize.<span class="built_in">STRING</span>(<span class="number">50</span>),</span><br><span class="line">        primaryKey: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    usr: Sequelize.<span class="built_in">STRING</span>(<span class="number">100</span>),</span><br><span class="line">    name: Sequelize.<span class="built_in">STRING</span>(<span class="number">100</span>),</span><br><span class="line">    updateTime: Sequelize.<span class="built_in">DATE</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    timestamps: <span class="literal">false</span> <span class="comment">// 关闭Sequelize的自动添加时间戳的功能</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="5"><li>写数据</li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主键必须有值</span></span><br><span class="line">test.create(&#123;</span><br><span class="line">    'id': 'testId',</span><br><span class="line">    'usr': 'testUsr',</span><br><span class="line">    'name': 'testName'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="6"><li>删数据</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">notes</span><span class="selector-class">.destroy</span>(&#123;</span><br><span class="line"> <span class="attribute">where</span>: &#123;</span><br><span class="line"> <span class="string">'id'</span>: <span class="string">'123'</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="7"><li>改数据</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> ES6</span><br><span class="line">test.update(&#123;<span class="string">'name'</span>: <span class="string">'newName'</span>&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'where'</span>: &#123;</span><br><span class="line">        <span class="string">'id'</span>: <span class="string">'testId'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="params">(res)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).<span class="keyword">catch</span>((err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="8"><li>查数据</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES7</span></span><br><span class="line">(<span class="keyword">async</span> ()=&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> test.find(&#123;</span><br><span class="line">        attributes: [<span class="string">'name'</span>, <span class="string">'usr'</span>],</span><br><span class="line">        <span class="keyword">where</span>: &#123;</span><br><span class="line">            <span class="string">'id'</span>: <span class="string">'123'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        timestamps: <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">console.log(res);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p><strong>注：sequelize数据类型表传送门：<a href="https://blog.csdn.net/zdluoa/article/details/81194215" target="_blank" rel="noopener">https://blog.csdn.net/zdluoa/article/details/81194215</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> Node.js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
